var emmet = function (e) { function o(e, t, n) { var r; if (t && t.hasOwnProperty("constructor")) { r = t.constructor } else { r = function () { e.apply(this, arguments) } } _.extend(r, e); s.prototype = e.prototype; r.prototype = new s; if (t) _.extend(r.prototype, t); if (n) _.extend(r, n); r.prototype.constructor = r; r.__super__ = e.prototype; return r } function a(e) { if (!(e in i) && u) u(e); return i[e] } var t = "html"; var n = "plain"; if (typeof _ == "undefined") { try { _ = e[["require"][0]]("underscore") } catch (r) { } } if (typeof _ == "undefined") { throw "Cannot access to Underscore.js lib" } var i = { _: _ }; var s = function () { }; var u = null; return { define: function (e, t) { if (!(e in i)) { i[e] = _.isFunction(t) ? this.exec(t) : t } }, require: a, exec: function (t, n) { return t.call(n || e, _.bind(a, this), _, this) }, extend: function (e, t) { var n = o(this, e, t); n.extend = this.extend; if (e.hasOwnProperty("toString")) n.prototype.toString = e.toString; return n }, expandAbbreviation: function (e, n, r, i) { if (!e) return ""; n = n || t; var s = a("filters"); var o = a("abbreviationParser"); r = a("profile").get(r, n); a("tabStops").resetTabstopIndex(); var u = s.extractFromAbbreviation(e); var f = o.parse(u[0], { syntax: n, contextNode: i }); var l = s.composeList(n, r, u[1]); s.apply(f, l, r); return f.toString() }, defaultSyntax: function () { return t }, defaultProfile: function () { return n }, log: function () { if (e.console && e.console.log) e.console.log.apply(e.console, arguments) }, setModuleLoader: function (e) { u = e } } }(this); if (typeof exports !== "undefined") { if (typeof module !== "undefined" && module.exports) { exports = module.exports = emmet } exports.emmet = emmet } if (typeof define !== "undefined") { define("emmet", [], emmet) } emmet.define("abbreviationParser", function (e, t) { function f(e) { this.parent = null; this.children = []; this._attributes = []; this.abbreviation = ""; this.counter = 1; this._name = null; this._text = ""; this.repeatCount = 1; this.hasImplicitRepeat = false; this._data = {}; this.start = ""; this.end = ""; this.content = ""; this.padding = "" } function l(e) { return e.substring(1, e.length - 1) } function c(e, t) { var n; while (n = e.next()) { if (n === t) return true; if (n == "\\") continue } return false } function h(n) { n = e("utils").trim(n); var r = new f; var s = r.addChild(), o; var u = e("stringStream").create(n); var a = 1e3, c; while (!u.eol() && --a > 0) { o = u.peek(); switch (o) { case "(": u.start = u.pos; if (u.skipToPair("(", ")")) { var p = h(l(u.current())); if (c = u.match(/^\*(\d+)?/, true)) { s._setRepeat(c[1]) } t.each(p.children, function (e) { s.addChild(e) }) } else { throw 'Invalid abbreviation: mo matching ")" found for character at ' + u.pos } break; case ">": s = s.addChild(); u.next(); break; case "+": s = s.parent.addChild(); u.next(); break; case "^": var d = s.parent || s; s = (d.parent || d).addChild(); u.next(); break; default: u.start = u.pos; u.eatWhile(function (e) { if (e == "[" || e == "{") { if (u.skipToPair(e, i[e])) { u.backUp(1); return true } throw 'Invalid abbreviation: mo matching "' + i[e] + '" found for character at ' + u.pos } if (e == "+") { u.next(); var t = u.eol() || ~"+>^*".indexOf(u.peek()); u.backUp(1); return t } return e != "(" && b(e) }); s.setAbbreviation(u.current()); u.start = u.pos } } if (a < 1) throw "Endless loop detected"; return r } function p(t, n) { t = e("utils").trim(t); var i = []; var s = e("stringStream").create(t); s.eatSpace(); while (!s.eol()) { s.start = s.pos; if (s.eatWhile(r)) { var o = s.current(); var u = ""; if (s.peek() == "=") { s.next(); s.start = s.pos; var a = s.peek(); if (a == '"' || a == "'") { s.next(); if (c(s, a)) { u = s.current(); u = u.substring(1, u.length - 1) } else { throw "Invalid attribute value" } } else if (s.eatWhile(/[^\s\]]/)) { u = s.current() } else { throw "Invalid attribute value" } } i.push({ name: o, value: u }); s.eatSpace() } else { break } } return i } function d(t) { var n = []; var i = { "#": "id", ".": "class" }; var s = null; var o = e("stringStream").create(t); while (!o.eol()) { switch (o.peek()) { case "#": case ".": if (s === null) s = o.pos; var u = i[o.peek()]; o.next(); o.start = o.pos; o.eatWhile(r); n.push({ name: u, value: o.current() }); break; case "[": if (s === null) s = o.pos; o.start = o.pos; if (!o.skipToPair("[", "]")) throw "Invalid attribute set definition"; n = n.concat(p(l(o.current()))); break; default: o.next() } } if (!n.length) return null; return { element: t.substring(0, s), attributes: v(n) } } function v(e) { e = t.map(e, function (e) { return t.clone(e) }); var n = {}; return t.filter(e, function (e) { if (!(e.name in n)) { return n[e.name] = e } var t = n[e.name]; if (e.name.toLowerCase() == "class") { t.value += (t.value.length ? " " : "") + e.value } else { t.value = e.value } return false }) } function m(t) { if (!~t.indexOf("{")) return null; var n = e("stringStream").create(t); while (!n.eol()) { switch (n.peek()) { case "[": case "(": n.skipToPair(n.peek(), i[n.peek()]); break; case "{": n.start = n.pos; n.skipToPair("{", "}"); return { element: t.substring(0, n.start), text: l(n.current()) }; default: n.next() } } } function g(e) { for (var n = e.children.length - 1, r, i, s; n >= 0; n--) { i = e.children[n]; if (i.isRepeating()) { s = r = i.repeatCount; i.repeatCount = 1; i.updateProperty("counter", 1); i.updateProperty("maxCount", s); while (--r > 0) { i.parent.addChild(i.clone(), n + 1).updateProperty("counter", r + 1).updateProperty("maxCount", s) } } } t.each(e.children, g); return e } function y(e) { for (var n = e.children.length - 1; n >= 0; n--) { var r = e.children[n]; if (r.isGroup()) { r.replace(y(r).children) } else if (r.isEmpty()) { r.remove() } } t.each(e.children, y); return e } function b(e) { var t = e.charCodeAt(0); var n = "#.*:$-_!@|%"; return t > 64 && t < 91 || t > 96 && t < 123 || t > 47 && t < 58 || n.indexOf(e) != -1 } var n = /^[\w\-\$\:@\!%]+\+?$/i; var r = /[\w\-:\$@]/; var i = { "[": "]", "(": ")", "{": "}" }; var s = Array.prototype.splice; var o = []; var u = []; var a = []; f.prototype = { addChild: function (e, n) { e = e || new f; e.parent = this; if (t.isUndefined(n)) { this.children.push(e) } else { this.children.splice(n, 0, e) } return e }, clone: function () { var e = new f; var n = ["abbreviation", "counter", "_name", "_text", "repeatCount", "hasImplicitRepeat", "start", "end", "content", "padding"]; t.each(n, function (t) { e[t] = this[t] }, this); e._attributes = t.map(this._attributes, function (e) { return t.clone(e) }); e._data = t.clone(this._data); e.children = t.map(this.children, function (t) { t = t.clone(); t.parent = e; return t }); return e }, remove: function () { if (this.parent) { this.parent.children = t.without(this.parent.children, this) } return this }, replace: function () { var e = this.parent; var n = t.indexOf(e.children, this); var r = t.flatten(arguments); s.apply(e.children, [n, 1].concat(r)); t.each(r, function (t) { t.parent = e }) }, updateProperty: function (e, n) { this[e] = n; t.each(this.children, function (t) { t.updateProperty(e, n) }); return this }, find: function (e) { return this.findAll(e)[0] }, findAll: function (e) { if (!t.isFunction(e)) { var n = e.toLowerCase(); e = function (e) { return e.name().toLowerCase() == n } } var r = []; t.each(this.children, function (t) { if (e(t)) r.push(t); r = r.concat(t.findAll(e)) }); return t.compact(r) }, data: function (t, n) { if (arguments.length == 2) { this._data[t] = n; if (t == "resource" && e("elements").is(n, "snippet")) { this.content = n.data; if (this._text) { this.content = e("abbreviationUtils").insertChildContent(n.data, this._text) } } } return this._data[t] }, name: function () { var t = this.matchedResource(); if (e("elements").is(t, "element")) { return t.name } return this._name }, attributeList: function () { var n = []; var r = this.matchedResource(); if (e("elements").is(r, "element") && t.isArray(r.attributes)) { n = n.concat(r.attributes) } return v(n.concat(this._attributes)) }, attribute: function (e, n) { if (arguments.length == 2) { var r = t.indexOf(t.pluck(this._attributes, "name"), e.toLowerCase()); if (~r) { this._attributes[r].value = n } else { this._attributes.push({ name: e, value: n }) } } return (t.find(this.attributeList(), function (t) { return t.name == e }) || {}).value }, matchedResource: function () { return this.data("resource") }, index: function () { return this.parent ? t.indexOf(this.parent.children, this) : -1 }, _setRepeat: function (e) { if (e) { this.repeatCount = parseInt(e, 10) || 1 } else { this.hasImplicitRepeat = true } }, setAbbreviation: function (e) { e = e || ""; var t = this; e = e.replace(/\*(\d+)?$/, function (e, n) { t._setRepeat(n); return "" }); this.abbreviation = e; var r = m(e); if (r) { e = r.element; this.content = this._text = r.text } var i = d(e); if (i) { e = i.element; this._attributes = i.attributes } this._name = e; if (this._name && !n.test(this._name)) { throw "Invalid abbreviation" } }, toString: function () { var n = e("utils"); var r = this.start; var i = this.end; var s = this.content; var o = this; t.each(a, function (e) { r = e(r, o, "start"); s = e(s, o, "content"); i = e(i, o, "end") }); var u = t.map(this.children, function (e) { return e.toString() }).join(""); s = e("abbreviationUtils").insertChildContent(s, u, { keepVariable: false }); return r + n.padString(s, this.padding) + i }, hasEmptyChildren: function () { return !!t.find(this.children, function (e) { return e.isEmpty() }) }, hasImplicitName: function () { return !this._name && !this.isTextNode() }, isGroup: function () { return !this.abbreviation }, isEmpty: function () { return !this.abbreviation && !this.children.length }, isRepeating: function () { return this.repeatCount > 1 || this.hasImplicitRepeat }, isTextNode: function () { return !this.name() && !this.attributeList().length }, isElement: function () { return !this.isEmpty() && !this.isTextNode() }, deepestChild: function () { if (!this.children.length) return null; var e = this; while (e.children.length) { e = t.last(e.children) } return e } }; a.push(function (t, n) { return e("utils").replaceCounter(t, n.counter, n.maxCount) }); return { parse: function (e, n) { n = n || {}; var r = h(e); if (n.contextNode) { r._name = n.contextNode.name; var i = {}; t.each(r._attributes, function (e) { i[e.name] = e }); t.each(n.contextNode.attributes, function (e) { if (e.name in i) { i[e.name].value = e.value } else { e = t.clone(e); r._attributes.push(e); i[e.name] = e } }) } t.each(o, function (e) { e(r, n) }); r = y(g(r)); t.each(u, function (e) { e(r, n) }); return r }, AbbreviationNode: f, addPreprocessor: function (e) { if (!t.include(o, e)) o.push(e) }, removeFilter: function (e) { preprocessor = t.without(o, e) }, addPostprocessor: function (e) { if (!t.include(u, e)) u.push(e) }, removePostprocessor: function (e) { u = t.without(u, e) }, addOutputProcessor: function (e) { if (!t.include(a, e)) a.push(e) }, removeOutputProcessor: function (e) { a = t.without(a, e) }, isAllowedChar: function (e) { e = String(e); return b(e) || ~">+^[](){}".indexOf(e) } } }); emmet.exec(function (e, t) { function n(r, i) { var s = e("resources"); var o = e("elements"); var u = e("abbreviationParser"); t.each(t.clone(r.children), function (e) { var r = s.getMatchedResource(e, i); if (t.isString(r)) { e.data("resource", o.create("snippet", r)) } else if (o.is(r, "reference")) { var a = u.parse(r.data, { syntax: i }); if (e.repeatCount > 1) { var f = a.findAll(function (e) { return e.hasImplicitRepeat }); t.each(f, function (t) { t.repeatCount = e.repeatCount; t.hasImplicitRepeat = false }) } var l = a.deepestChild(); if (l) { t.each(e.children, function (e) { l.addChild(e) }) } t.each(a.children, function (n) { t.each(e.attributeList(), function (e) { n.attribute(e.name, e.value) }) }); e.replace(a.children) } else { e.data("resource", r) } n(e, i) }) } e("abbreviationParser").addPreprocessor(function (e, t) { var r = t.syntax || emmet.defaultSyntax(); n(e, r) }) }); emmet.exec(function (e, t) { function i(t) { var n = e("range"); var i = []; var s = e("stringStream").create(t); while (!s.eol()) { if (s.peek() == "\\") { s.next() } else { s.start = s.pos; if (s.match(r, true)) { i.push(n.create(s.start, r)); continue } } s.next() } return i } function s(n, r) { var s = e("utils"); var o = i(n); o.reverse(); t.each(o, function (e) { n = s.replaceSubstring(n, r, e) }); return n } function o(e) { if (i(e.content).length) return true; return !!t.find(e.attributeList(), function (e) { return !!i(e.value).length }) } function u(n, r, i) { var u = n.findAll(function (e) { return o(e) }); if (o(n)) u.unshift(n); if (u.length) { t.each(u, function (e) { e.content = s(e.content, r); t.each(e._attributes, function (e) { e.value = s(e.value, r) }) }) } else { var a = n.deepestChild() || n; if (i) { a.content = r } else { a.content = e("abbreviationUtils").insertChildContent(a.content, r) } } } var n = e("abbreviationParser"); var r = "$#"; n.addPreprocessor(function (n, r) { if (r.pastedContent) { var i = e("utils"); var s = t.map(i.splitByLines(r.pastedContent, true), i.trim); n.findAll(function (e) { if (e.hasImplicitRepeat) { e.data("paste", s); return e.repeatCount = s.length } }) } }); n.addPostprocessor(function (e, n) { var r = e.findAll(function (e) { var n = e.data("paste"); var r = ""; if (t.isArray(n)) { r = n[e.counter - 1] } else if (t.isFunction(n)) { r = n(e.counter - 1, e.content) } else if (n) { r = n } if (r) { u(e, r, !!e.data("pasteOverwrites")) } e.data("paste", null); return !!n }); if (!r.length && n.pastedContent) { u(e, n.pastedContent) } }) }); emmet.exec(function (e, t) { function n(r) { var i = e("tagName"); t.each(r.children, function (e) { if (e.hasImplicitName() || e.data("forceNameResolving")) { e._name = i.resolve(e.parent.name()) } n(e) }); return r } e("abbreviationParser").addPostprocessor(n) }); emmet.define("cssParser", function (e, t) { function u(e) { return typeof e !== "undefined" } function a() { return { "char": n.chnum, line: n.linenum } } function f(e, t, i) { var s = n, o = i || {}; r.push({ charstart: u(o["char"]) ? o["char"] : s.chnum, charend: u(o.charend) ? o.charend : s.chnum, linestart: u(o.line) ? o.line : s.linenum, lineend: u(o.lineend) ? o.lineend : s.linenum, value: e, type: t || e }) } function l(e, t) { var i = n, s = t || {}, o = u(s["char"]) ? s["char"] : i.chnum, a = u(s.line) ? s.line : i.linenum; return { name: "ParseError", message: e + " at line " + (a + 1) + " char " + (o + 1), walker: i, tokens: r } } function c() { var e = n.ch, t = "", r = a(); while (e === " " || e === "	") { t += e; e = n.nextChar() } f(t, "white", r) } function h() { var e = n, t = e.ch, r = t, i, s = a(); i = e.nextChar(); if (i === "/") { r += i; var o = e.peek(); while (o && o !== "\n") { r += i; i = e.nextChar(); o = e.peek() } } else if (i === "*") { while (!(t === "*" && i === "/")) { r += i; t = i; i = e.nextChar() } } else { s.charend = s["char"]; s.lineend = s.line; return f(r, r, s) } r += i; e.nextChar(); f(r, "comment", s) } function p() { var e = n, t = e.ch, r = t, i = t, s, o = a(); t = e.nextChar(); while (t !== r) { if (t === "\n") { s = e.nextChar(); if (s === "\\") { i += t + s } else { throw l("Unterminated string", o) } } else { if (t === "\\") { i += t + e.nextChar() } else { i += t } } t = e.nextChar() } i += t; e.nextChar(); f(i, "string", o) } function d() { var e = n, t = e.ch, r = 0, i = t, s = a(); t = e.nextChar(); while (t !== ")" && !r) { if (t === "(") { r++ } else if (t === ")") { r-- } else if (t === false) { throw l("Unterminated brace", s) } i += t; t = e.nextChar() } i += t; e.nextChar(); f(i, "brace", s) } function v(e) { var t = n, r = t.ch, i = a(), u = e ? e + r : r; r = t.nextChar(); if (e) { i["char"] -= e.length } while (s(r) || o(r)) { u += r; r = t.nextChar() } f(u, "identifier", i) } function m() { var e = n, t = e.ch, r = a(), i = t, s = i === ".", u; t = e.nextChar(); u = !o(t); if (s && u) { r.charend = r["char"]; r.lineend = r.line; return f(i, ".", r) } if (i === "-" && u) { return v("-") } while (t !== false && (o(t) || !s && t === ".")) { if (t === ".") { s = true } i += t; t = e.nextChar() } f(i, "number", r) } function g() { var e = n, t = e.ch, r = a(), s = t, o = e.nextChar(); if (o === "=" && i(s, true)) { s += o; f(s, "match", r); e.nextChar(); return } r.charend = r["char"] + 1; r.lineend = r.line; f(s, s, r) } function y() { var e = n.ch; if (e === " " || e === "	") { return c() } if (e === "/") { return h() } if (e === '"' || e === "'") { return p() } if (e === "(") { return d() } if (e === "-" || e === "." || o(e)) { return m() } if (s(e)) { return v() } if (i(e)) { return g() } if (e === "\n") { f("line"); n.nextChar(); return } throw l("Unrecognized character") } function b(e, t) { return e.charAt(t) == "\r" && e.charAt(t + 1) == "\n" ? "\r\n" : e.charAt(t) } var n, r = [], i, s, o; n = { lines: null, total_lines: 0, linenum: -1, line: "", ch: "", chnum: -1, init: function (e) { var t = n; t.lines = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n"); t.total_lines = t.lines.length; t.chnum = -1; t.linenum = -1; t.ch = ""; t.line = ""; t.nextLine(); t.nextChar() }, nextLine: function () { var e = this; e.linenum += 1; if (e.total_lines <= e.linenum) { e.line = false } else { e.line = e.lines[e.linenum] } if (e.chnum !== -1) { e.chnum = 0 } return e.line }, nextChar: function () { var e = this; e.chnum += 1; while (e.line.charAt(e.chnum) === "") { if (this.nextLine() === false) { e.ch = false; return false } e.chnum = -1; e.ch = "\n"; return "\n" } e.ch = e.line.charAt(e.chnum); return e.ch }, peek: function () { return this.line.charAt(this.chnum + 1) } }; s = function (e) { return e == "&" || e === "_" || e === "-" || e >= "a" && e <= "z" || e >= "A" && e <= "Z" }; o = function (e) { return e !== false && e >= "0" && e <= "9" }; i = function () { var e = "{}[]()+*=.,;:>~|\\%$#@^!".split(""), t = "*^|$~".split(""), n = {}, r = {}, i = 0; for (; i < e.length; i += 1) { n[e[i]] = true } for (i = 0; i < t.length; i += 1) { r[t[i]] = true } return function (e, t) { if (t) { return !!r[e] } return !!n[e] } }(); return { lex: function (e) { n.init(e); r = []; while (n.ch !== false) { y() } return r }, parse: function (e) { var n = 0; return t.map(this.lex(e), function (t) { if (t.type == "line") { t.value = b(e, n) } return { type: t.type, start: n, end: n += t.value.length } }) }, toSource: function (e) { var t = 0, n = e.length, r, i = ""; for (; t < n; t += 1) { r = e[t]; if (r.type === "line") { i += "\n" } else { i += r.value } } return i } } }); emmet.define("xmlParser", function (e, t) { function s(e, t) { function n(n) { t.tokenize = n; return n(e, t) } var s = e.next(); if (s == "<") { if (e.eat("!")) { if (e.eat("[")) { if (e.match("CDATA[")) return n(a("atom", "]]>")); else return null } else if (e.match("--")) return n(a("comment", "-->")); else if (e.match("DOCTYPE", true, true)) { e.eatWhile(/[\w\._\-]/); return n(f(1)) } else return null } else if (e.eat("?")) { e.eatWhile(/[\w\._\-]/); t.tokenize = a("meta", "?>"); return "meta" } else { i = e.eat("/") ? "closeTag" : "openTag"; e.eatSpace(); r = ""; var u; while (u = e.eat(/[^\s\u00a0=<>\"\'\/?]/)) r += u; t.tokenize = o; return "tag" } } else if (s == "&") { var l; if (e.eat("#")) { if (e.eat("x")) { l = e.eatWhile(/[a-fA-F\d]/) && e.eat(";") } else { l = e.eatWhile(/[\d]/) && e.eat(";") } } else { l = e.eatWhile(/[\w\.\-:]/) && e.eat(";") } return l ? "atom" : "error" } else { e.eatWhile(/[^&<]/); return "text" } } function o(e, t) { var n = e.next(); if (n == ">" || n == "/" && e.eat(">")) { t.tokenize = s; i = n == ">" ? "endTag" : "selfcloseTag"; return "tag" } else if (n == "=") { i = "equals"; return null } else if (/[\'\"]/.test(n)) { t.tokenize = u(n); return t.tokenize(e, t) } else { e.eatWhile(/[^\s\u00a0=<>\"\'\/?]/); return "word" } } function u(e) { return function (t, n) { while (!t.eol()) { if (t.next() == e) { n.tokenize = o; break } } return "string" } } function a(e, t) { return function (n, r) { while (!n.eol()) { if (n.match(t)) { r.tokenize = s; break } n.next() } return e } } function f(e) { return function (t, n) { var r; while ((r = t.next()) != null) { if (r == "<") { n.tokenize = f(e + 1); return n.tokenize(t, n) } else if (r == ">") { if (e == 1) { n.tokenize = s; break } else { n.tokenize = f(e - 1); return n.tokenize(t, n) } } } return "meta" } } function h() { for (var e = arguments.length - 1; e >= 0; e--) l.cc.push(arguments[e]) } function p() { h.apply(null, arguments); return true } function d(e, t) { var r = n.doNotIndent.hasOwnProperty(e) || l.context && l.context.noIndent; l.context = { prev: l.context, tagName: e, indent: l.indented, startOfLine: t, noIndent: r } } function v() { if (l.context) l.context = l.context.prev } function m(e) { if (e == "openTag") { l.tagName = r; return p(w, g(l.startOfLine)) } else if (e == "closeTag") { var t = false; if (l.context) { if (l.context.tagName != r) { if (n.implicitlyClosed.hasOwnProperty(l.context.tagName.toLowerCase())) { v() } t = !l.context || l.context.tagName != r } } else { t = true } if (t) c = "error"; return p(y(t)) } return p() } function g(e) { return function (t) { if (t == "selfcloseTag" || t == "endTag" && n.autoSelfClosers.hasOwnProperty(l.tagName.toLowerCase())) { b(l.tagName.toLowerCase()); return p() } if (t == "endTag") { b(l.tagName.toLowerCase()); d(l.tagName, e); return p() } return p() } } function y(e) { return function (t) { if (e) c = "error"; if (t == "endTag") { v(); return p() } c = "error"; return p(arguments.callee) } } function b(e) { var t; while (true) { if (!l.context) { return } t = l.context.tagName.toLowerCase(); if (!n.contextGrabbers.hasOwnProperty(t) || !n.contextGrabbers[t].hasOwnProperty(e)) { return } v() } } function w(e) { if (e == "word") { c = "attribute"; return p(E, w) } if (e == "endTag" || e == "selfcloseTag") return h(); c = "error"; return p(w) } function E(e) { if (e == "equals") return p(S, w); if (!n.allowMissing) c = "error"; return e == "endTag" || e == "selfcloseTag" ? h() : p() } function S(e) { if (e == "string") return p(x); if (e == "word" && n.allowUnquoted) { c = "string"; return p() } c = "error"; return e == "endTag" || e == "selfCloseTag" ? h() : p() } function x(e) { if (e == "string") return p(x); else return h() } function T() { return { tokenize: s, cc: [], indented: 0, startOfLine: true, tagName: null, context: null } } function N(e, t) { if (e.sol()) { t.startOfLine = true; t.indented = 0 } if (e.eatSpace()) return null; c = i = r = null; var n = t.tokenize(e, t); t.type = i; if ((n || i) && n != "comment") { l = t; while (true) { var s = t.cc.pop() || m; if (s(i || n)) break } } t.startOfLine = false; return c || n } var n = { autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: true, allowMissing: true }; var r = null, i = null; var l = null, c; return { parse: function (t, n) { n = n || 0; var r = T(); var i = e("stringStream").create(t); var s = []; while (!i.eol()) { s.push({ type: N(i, r), start: i.start + n, end: i.pos + n }); i.start = i.pos } return s } } }); emmet.define("string-score", function (e, t) { return { score: function (e, t, n) { if (e == t) { return 1 } if (t == "") { return 0 } var r = 0, i = t.length, s = e.length, o, u, a = 1, f; for (var l = 0, c, h, p, d, v, m; l < i; ++l) { p = t.charAt(l); d = e.indexOf(p.toLowerCase()); v = e.indexOf(p.toUpperCase()); m = Math.min(d, v); h = m > -1 ? m : Math.max(d, v); if (h === -1) { if (n) { a += 1 - n; continue } else { return 0 } } else { c = .1 } if (e[h] === p) { c += .1 } if (h === 0) { c += .6; if (l === 0) { o = 1 } } else { if (e.charAt(h - 1) === " ") { c += .8 } } e = e.substring(h + 1, s); r += c } u = r / i; f = (u * (i / s) + u) / 2; f = f / a; if (o && f + .15 < 1) { f += .15 } return f } } }); emmet.define("utils", function (e, t) { function r(e) { this._data = []; this.length = 0; if (e) this.append(e) } var n = "${0}"; r.prototype = { append: function (e) { this._data.push(e); this.length += e.length }, toString: function () { return this._data.join("") }, valueOf: function () { return this.toString() } }; return { reTag: /<\/?[\w:\-]+(?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*\s*(\/?)>$/, endsWithTag: function (e) { return this.reTag.test(e) }, isNumeric: function (e) { if (typeof e == "string") e = e.charCodeAt(0); return e && e > 47 && e < 58 }, trim: function (e) { return (e || "").replace(/^\s+|\s+$/g, "") }, getNewline: function () { var n = e("resources"); if (!n) { return "\n" } var r = n.getVariable("newline"); return t.isString(r) ? r : "\n" }, setNewline: function (t) { var n = e("resources"); n.setVariable("newline", t); n.setVariable("nl", t) }, splitByLines: function (e, n) { var r = this.getNewline(); var i = (e || "").replace(/\r\n/g, "\n").replace(/\n\r/g, "\n").replace(/\r/g, "\n").replace(/\n/g, r).split(r); if (n) { i = t.filter(i, function (e) { return e.length && !!this.trim(e) }, this) } return i }, normalizeNewline: function (e) { return this.splitByLines(e).join(this.getNewline()) }, repeatString: function (e, t) { var n = []; for (var r = 0; r < t; r++) n.push(e); return n.join("") }, getStringsPads: function (e) { var n = t.map(e, function (e) { return t.isString(e) ? e.length : +e }); var r = t.max(n); return t.map(n, function (e) { var t = r - e; return t ? this.repeatString(" ", t) : "" }, this) }, padString: function (n, r) { var i = t.isNumber(r) ? this.repeatString(e("resources").getVariable("indentation") || "	", r) : r; var s = []; var o = this.splitByLines(n); var u = this.getNewline(); s.push(o[0]); for (var a = 1; a < o.length; a++) s.push(u + i + o[a]); return s.join("") }, zeroPadString: function (e, t) { var n = ""; var r = e.length; while (t > r++) n += "0"; return n + e }, unindentString: function (e, t) { var n = this.splitByLines(e); for (var r = 0; r < n.length; r++) { if (n[r].search(t) == 0) n[r] = n[r].substr(t.length) } return n.join(this.getNewline()) }, replaceUnescapedSymbol: function (e, n, r) { var i = 0; var s = e.length; var o = n.length; var u = 0; while (i < s) { if (e.charAt(i) == "\\") { i += o + 1 } else if (e.substr(i, o) == n) { var a = o; u++; var f = r; if (t.isFunction(r)) { var l = r(e, n, i, u); if (l) { a = l[0].length; f = l[1] } else { f = false } } if (f === false) { i++; continue } e = e.substring(0, i) + f + e.substring(i + a); s = e.length; i += f.length } else { i++ } } return e }, replaceVariables: function (n, r) { r = r || {}; var i = t.isFunction(r) ? r : function (e, t) { return t in r ? r[t] : null }; var s = e("resources"); return e("tabStops").processText(n, { variable: function (e) { var n = i(e.token, e.name, e); if (n === null) { n = s.getVariable(e.name) } if (n === null || t.isUndefined(n)) n = e.token; return n } }) }, replaceCounter: function (e, n, r) { var i = "$"; e = String(e); n = String(n); if (/^\-?\d+$/.test(n)) { n = +n } var s = this; return this.replaceUnescapedSymbol(e, i, function (e, i, o, u) { if (e.charAt(o + 1) == "{" || s.isNumeric(e.charAt(o + 1))) { return false } var a = o + 1; while (e.charAt(a) == "$" && e.charAt(a + 1) != "{") a++; var f = a - o; var l = 0, c = false, h; if (h = e.substr(a).match(/^@(\-?)(\d*)/)) { a += h[0].length; if (h[1]) { c = true } l = parseInt(h[2] || 1) - 1 } if (c && r && t.isNumber(n)) { n = r - n + 1 } n += l; return [e.substring(o, a), s.zeroPadString(n + "", f)] }) }, matchesTag: function (e) { return this.reTag.test(e || "") }, escapeText: function (e) { return e.replace(/([\$\\])/g, "\\$1") }, unescapeText: function (e) { return e.replace(/\\(.)/g, "$1") }, getCaretPlaceholder: function () { return t.isFunction(n) ? n.apply(this, arguments) : n }, setCaretPlaceholder: function (e) { n = e }, getLinePadding: function (e) { return (e.match(/^(\s+)/) || [""])[0] }, getLinePaddingFromPosition: function (e, t) { var n = this.findNewlineBounds(e, t); return this.getLinePadding(n.substring(e)) }, escapeForRegexp: function (e) { var t = new RegExp("[.*+?|()\\[\\]{}\\\\]", "g"); return e.replace(t, "\\$&") }, prettifyNumber: function (e, t) { return e.toFixed(typeof t == "undefined" ? 2 : t).replace(/\.?0+$/, "") }, stringBuilder: function (e) { return new r(e) }, replaceSubstring: function (e, n, r, i) { if (t.isObject(r) && "end" in r) { i = r.end; r = r.start } if (t.isString(i)) i = r + i.length; if (t.isUndefined(i)) i = r; if (r < 0 || r > e.length) return e; return e.substring(0, r) + n + e.substring(i) }, narrowToNonSpace: function (t, n, r) { var i = e("range").create(n, r); var s = /[\s\n\r\u00a0]/; while (i.start < i.end) { if (!s.test(t.charAt(i.start))) break; i.start++ } while (i.end > i.start) { i.end--; if (!s.test(t.charAt(i.end))) { i.end++; break } } return i }, findNewlineBounds: function (t, n) { var r = t.length, i = 0, s = r - 1; for (var o = n - 1; o > 0; o--) { var u = t.charAt(o); if (u == "\n" || u == "\r") { i = o + 1; break } } for (var a = n; a < r; a++) { var u = t.charAt(a); if (u == "\n" || u == "\r") { s = a; break } } return e("range").create(i, s - i) }, deepMerge: function () { var e, n, r, i, s, o, u = arguments[0] || {}, a = 1, f = arguments.length; if (!t.isObject(u) && !t.isFunction(u)) { u = {} } for (; a < f; a++) { if ((e = arguments[a]) != null) { for (n in e) { r = u[n]; i = e[n]; if (u === i) { continue } if (i && (t.isObject(i) || (s = t.isArray(i)))) { if (s) { s = false; o = r && t.isArray(r) ? r : [] } else { o = r && t.isObject(r) ? r : {} } u[n] = this.deepMerge(o, i) } else if (i !== undefined) { u[n] = i } } } } return u } } }); emmet.define("range", function (e, t) { function n(e, t, n) { switch (n) { case "eq": case "==": return e === t; case "lt": case "<": return e < t; case "lte": case "<=": return e <= t; case "gt": case ">": return e > t; case "gte": case ">=": return e >= t } } function r(e, n) { if (t.isObject(e) && "start" in e) { this.start = Math.min(e.start, e.end); this.end = Math.max(e.start, e.end) } else if (t.isArray(e)) { this.start = e[0]; this.end = e[1] } else { n = t.isString(n) ? n.length : +n; this.start = e; this.end = e + n } } r.prototype = { length: function () { return Math.abs(this.end - this.start) }, equal: function (e) { return this.cmp(e, "eq", "eq") }, shift: function (e) { this.start += e; this.end += e; return this }, overlap: function (e) { return e.start <= this.end && e.end >= this.start }, intersection: function (e) { if (this.overlap(e)) { var t = Math.max(e.start, this.start); var n = Math.min(e.end, this.end); return new r(t, n - t) } return null }, union: function (e) { if (this.overlap(e)) { var t = Math.min(e.start, this.start); var n = Math.max(e.end, this.end); return new r(t, n - t) } return null }, inside: function (e) { return this.cmp(e, "lte", "gt") }, contains: function (e) { return this.cmp(e, "lt", "gt") }, include: function (e) { return this.cmp(loc, "lte", "gte") }, cmp: function (e, t, i) { var s, o; if (e instanceof r) { s = e.start; o = e.end } else { s = o = e } return n(this.start, s, t || "<=") && n(this.end, o, i || ">") }, substring: function (e) { return this.length() > 0 ? e.substring(this.start, this.end) : "" }, clone: function () { return new r(this.start, this.length()) }, toArray: function () { return [this.start, this.end] }, toString: function () { return "{" + this.start + ", " + this.length() + "}" } }; return { create: function (e, n) { if (t.isUndefined(e) || e === null) return null; if (e instanceof r) return e; if (t.isObject(e) && "start" in e && "end" in e) { n = e.end - e.start; e = e.start } return new r(e, n) }, create2: function (e, n) { if (t.isNumber(e) && t.isNumber(n)) { n -= e } return this.create(e, n) } } }); emmet.define("handlerList", function (e, t) { function n() { this._list = [] } n.prototype = { add: function (e, n) { this._list.push(t.extend({ order: 0 }, n || {}, { fn: e })) }, remove: function (e) { this._list = t.without(this._list, t.find(this._list, function (t) { return t.fn === e })) }, list: function () { return t.sortBy(this._list, "order").reverse() }, listFn: function () { return t.pluck(this.list(), "fn") }, exec: function (e, n) { n = n || []; var r = null; t.find(this.list(), function (t) { r = t.fn.apply(t, n); if (r !== e) return true }); return r } }; return { create: function () { return new n } } }); emmet.define("tokenIterator", function (e, t) { function n(e) { this.tokens = e; this._position = 0; this.reset() } n.prototype = { next: function () { if (this.hasNext()) { var e = this.tokens[++this._i]; this._position = e.start; return e } return null }, current: function () { return this.tokens[this._i] }, position: function () { return this._position }, hasNext: function () { return this._i < this._il - 1 }, reset: function () { this._i = -1; this._il = this.tokens.length }, item: function () { return this.tokens[this._i] }, itemNext: function () { return this.tokens[this._i + 1] }, itemPrev: function () { return this.tokens[this._i - 1] }, nextUntil: function (e, n) { var r; var i = t.isString(e) ? function (t) { return t.type == e } : e; while (r = this.next()) { if (n) n.call(this, r); if (i.call(this, r)) break } } }; return { create: function (e) { return new n(e) } } }); emmet.define("stringStream", function (e, t) { function n(e) { this.pos = this.start = 0; this.string = e } n.prototype = { eol: function () { return this.pos >= this.string.length }, sol: function () { return this.pos == 0 }, peek: function () { return this.string.charAt(this.pos) }, next: function () { if (this.pos < this.string.length) return this.string.charAt(this.pos++) }, eat: function (e) { var t = this.string.charAt(this.pos), n; if (typeof e == "string") n = t == e; else n = t && (e.test ? e.test(t) : e(t)); if (n) { ++this.pos; return t } }, eatWhile: function (e) { var t = this.pos; while (this.eat(e)) { } return this.pos > t }, eatSpace: function () { var e = this.pos; while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))++this.pos; return this.pos > e }, skipToEnd: function () { this.pos = this.string.length }, skipTo: function (e) { var t = this.string.indexOf(e, this.pos); if (t > -1) { this.pos = t; return true } }, skipToPair: function (e, t) { var n = 0, r; var i = this.pos, s = this.string.length; while (i < s) { r = this.string.charAt(i++); if (r == e) { n++ } else if (r == t) { n--; if (n < 1) { this.pos = i; return true } } } return false }, backUp: function (e) { this.pos -= e }, match: function (e, t, n) { if (typeof e == "string") { var r = n ? function (e) { return e.toLowerCase() } : function (e) { return e }; if (r(this.string).indexOf(r(e), this.pos) == this.pos) { if (t !== false) this.pos += e.length; return true } } else { var i = this.string.slice(this.pos).match(e); if (i && t !== false) this.pos += i[0].length; return i } }, current: function () { return this.string.slice(this.start, this.pos) } }; return { create: function (e) { return new n(e) } } }); emmet.define("resources", function (e, t) { function f(t) { var n = e("utils"); return n.replaceUnescapedSymbol(t, "|", n.getCaretPlaceholder()) } function l(t, n, r) { n = f(n); if (r == "snippets") { return e("elements").create("snippet", n) } if (r == "abbreviations") { return c(t, n) } } function c(t, n) { t = e("utils").trim(t); var r = e("elements"); var i; if (i = s.exec(n)) { return r.create("element", i[1], i[2], i[4] == "/") } else { return r.create("reference", n) } } function h(e) { return e.replace(/:$/, "").replace(/:/g, "-") } var n = "system"; var r = "user"; var i = {}; var s = /^<(\w+\:?[\w\-]*)((?:\s+[\w\:\-]+\s*=\s*(['"]).*?\3)*)\s*(\/?)>/; var o = {}; var u = {}; var a = e("handlerList").create(); return { setVocabulary: function (e, t) { i = {}; if (t == n) o = e; else u = e }, getVocabulary: function (e) { return e == n ? o : u }, getMatchedResource: function (e, n) { return a.exec(null, t.toArray(arguments)) || this.findSnippet(n, e.name()) }, getVariable: function (e) { return (this.getSection("variables") || {})[e] }, setVariable: function (e, t) { var n = this.getVocabulary("user") || {}; if (!("variables" in n)) n.variables = {}; n.variables[e] = t; this.setVocabulary(n, "user") }, hasSyntax: function (e) { return e in this.getVocabulary(r) || e in this.getVocabulary(n) }, addResolver: function (e, t) { a.add(e, t) }, removeResolver: function (e) { a.remove(e) }, getSection: function (n) { if (!n) return null; if (!(n in i)) { i[n] = e("utils").deepMerge({}, o[n], u[n]) } var r = i[n], s = t.rest(arguments), a; while (r && (a = s.shift())) { if (a in r) { r = r[a] } else { return null } } return r }, findItem: function (e, t) { var n = this.getSection(e); while (n) { if (t in n) return n[t]; n = this.getSection(n["extends"]) } }, findSnippet: function (e, n, r) { if (!e || !n) return null; r = r || []; var i = [n]; if (~n.indexOf("-")) i.push(n.replace(/\-/g, ":")); var s = this.getSection(e), o = null; t.find(["snippets", "abbreviations"], function (n) { var r = this.getSection(e, n); if (r) { return t.find(i, function (e) { if (r[e]) return o = l(e, r[e], n) }) } }, this); r.push(e); if (!o && s["extends"] && !t.include(r, s["extends"])) { return this.findSnippet(s["extends"], n, r) } return o }, fuzzyFindSnippet: function (n, r, i) { i = i || .3; var s = this.getAllSnippets(n); var o = e("string-score"); r = h(r); var u = t.map(s, function (e, t) { return { key: t, score: o.score(e.nk, r, .1) } }); var a = t.last(t.sortBy(u, "score")); if (a && a.score >= i) { var f = a.key; return s[f].parsedValue } }, getAllSnippets: function (e) { var n = "all-" + e; if (!i[n]) { var r = [], s = e; var o = []; do { var u = this.getSection(s); if (!u) break; t.each(["snippets", "abbreviations"], function (e) { var n = {}; t.each(u[e] || null, function (t, r) { n[r] = { nk: h(r), value: t, parsedValue: l(r, t, e), type: e } }); r.push(n) }); o.push(s); s = u["extends"] } while (s && !t.include(o, s)); i[n] = t.extend.apply(t, r.reverse()) } return i[n] } } }); emmet.define("actions", function (e, t, n) { function i(t) { return e("utils").trim(t.charAt(0).toUpperCase() + t.substring(1).replace(/_[a-z]/g, function (e) { return " " + e.charAt(1).toUpperCase() })) } var r = {}; return { add: function (e, t, n) { e = e.toLowerCase(); n = n || {}; if (!n.label) { n.label = i(e) } r[e] = { name: e, fn: t, options: n } }, get: function (e) { return r[e.toLowerCase()] }, run: function (e, n) { if (!t.isArray(n)) { n = t.rest(arguments) } var r = this.get(e); if (r) { return r.fn.apply(emmet, n) } else { emmet.log('Action "%s" is not defined', e); return false } }, getAll: function () { return r }, getList: function () { return t.values(this.getAll()) }, getMenu: function (e) { var n = []; e = e || []; t.each(this.getList(), function (r) { if (r.options.hidden || t.include(e, r.name)) return; var s = i(r.name); var o = n; if (r.options.label) { var u = r.options.label.split("/"); s = u.pop(); var a, f; while (a = u.shift()) { f = t.find(o, function (e) { return e.type == "submenu" && e.name == a }); if (!f) { f = { name: a, type: "submenu", items: [] }; o.push(f) } o = f.items } } o.push({ type: "action", name: r.name, label: s }) }); return n }, getActionNameForMenuTitle: function (e, n) { var r = null; t.find(n || this.getMenu(), function (t) { if (t.type == "action") { if (t.label == e || t.name == e) { return r = t.name } } else { return r = this.getActionNameForMenuTitle(e, t.items) } }, this); return r || null } } }); emmet.define("profile", function (e, t) { function i(e) { t.extend(this, r, e) } function s(e, t) { switch (String(t || "").toLowerCase()) { case "lower": return e.toLowerCase(); case "upper": return e.toUpperCase() } return e } function o(e, t) { return n[e.toLowerCase()] = new i(t) } function u() { o("xhtml"); o("html", { self_closing_tag: false }); o("xml", { self_closing_tag: true, tag_nl: true }); o("plain", { tag_nl: false, indent: false, place_cursor: false }); o("line", { tag_nl: false, indent: false, extraFilters: "s" }) } var n = {}; var r = { tag_case: "asis", attr_case: "asis", attr_quotes: "double", tag_nl: "decide", tag_nl_leaf: false, place_cursor: true, indent: true, inline_break: 3, self_closing_tag: "xhtml", filters: "", extraFilters: "" }; i.prototype = { tagName: function (e) { return s(e, this.tag_case) }, attributeName: function (e) { return s(e, this.attr_case) }, attributeQuote: function () { return this.attr_quotes == "single" ? "'" : '"' }, selfClosing: function (e) { if (this.self_closing_tag == "xhtml") return " /"; if (this.self_closing_tag === true) return "/"; return "" }, cursor: function () { return this.place_cursor ? e("utils").getCaretPlaceholder() : "" } }; u(); return { create: function (e, n) { if (arguments.length == 2) return o(e, n); else return new i(t.defaults(e || {}, r)) }, get: function (r, s) { if (!r && s) { var o = e("resources").findItem(s, "profile"); if (o) { r = o } } if (!r) { return n.plain } if (r instanceof i) { return r } if (t.isString(r) && r.toLowerCase() in n) { return n[r.toLowerCase()] } return this.create(r) }, remove: function (e) { e = (e || "").toLowerCase(); if (e in n) delete n[e] }, reset: function () { n = {}; u() }, stringCase: s } }); emmet.define("editorUtils", function (e, t) { return { isInsideTag: function (e, t) { var n = /^<\/?\w[\w\:\-]*.*?>/; var r = t; while (r > -1) { if (e.charAt(r) == "<") break; r-- } if (r != -1) { var i = n.exec(e.substring(r)); if (i && t > r && t < r + i[0].length) return true } return false }, outputInfo: function (e, t, n) { n = n || e.getProfileName(); return { syntax: String(t || e.getSyntax()), profile: n || null, content: String(e.getContent()) } }, unindent: function (t, n) { return e("utils").unindentString(n, this.getCurrentLinePadding(t)) }, getCurrentLinePadding: function (t) { return e("utils").getLinePadding(t.getCurrentLine()) } } }); emmet.define("actionUtils", function (e, t) { return { mimeTypes: { gif: "image/gif", png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg", svg: "image/svg+xml", html: "text/html", htm: "text/html" }, extractAbbreviation: function (t) { var n = t.length; var r = -1; var i = 0; var s = 0; var o = 0; var u = e("utils"); var a = e("abbreviationParser"); while (true) { n--; if (n < 0) { r = 0; break } var f = t.charAt(n); if (f == "]") { s++ } else if (f == "[") { if (!s) { r = n + 1; break } s-- } else if (f == "}") { o++ } else if (f == "{") { if (!o) { r = n + 1; break } o-- } else if (f == ")") { i++ } else if (f == "(") { if (!i) { r = n + 1; break } i-- } else { if (s || o) continue; else if (!a.isAllowedChar(f) || f == ">" && u.endsWithTag(t.substring(0, n + 1))) { r = n + 1; break } } } if (r != -1 && !o && !s && !i) return t.substring(r).replace(/^[\*\+\>\^]+/, ""); else return "" }, getImageSize: function (e) { var t = "PNG\r\n\n", n = "ÿØ", r = "GIF8", i = function () { return e.charCodeAt(s++) }; if (e.substr(0, 8) === t) { var s = e.indexOf("IHDR") + 4; return { width: i() << 24 | i() << 16 | i() << 8 | i(), height: i() << 24 | i() << 16 | i() << 8 | i() } } else if (e.substr(0, 4) === r) { s = 6; return { width: i() | i() << 8, height: i() | i() << 8 } } else if (e.substr(0, 2) === n) { s = 2; var o = e.length; while (s < o) { if (i() != 255) return; var u = i(); if (u == 218) break; var a = i() << 8 | i(); if (u >= 192 && u <= 207 && !(u & 4) && !(u & 8)) { s += 1; return { height: i() << 8 | i(), width: i() << 8 | i() } } else { s += a - 2 } } } }, captureContext: function (n) { var r = { html: 1, xml: 1, xsl: 1 }; var i = String(n.getSyntax()); if (i in r) { var s = String(n.getContent()); var o = e("htmlMatcher").find(s, n.getCaretPos()); if (o && o.type == "tag") { var u = o.open; var a = { name: u.name, attributes: [] }; var f = e("xmlEditTree").parse(u.range.substring(s)); if (f) { a.attributes = t.map(f.getAll(), function (e) { return { name: e.name(), value: e.value() } }) } return a } } return null }, findExpressionBounds: function (t, n) { var r = String(t.getContent()); var i = r.length; var s = t.getCaretPos() - 1; var o = s + 1; while (s >= 0 && n(r.charAt(s), s, r)) s--; while (o < i && n(r.charAt(o), o, r)) o++; if (o > s) { return e("range").create([++s, o]) } }, compoundUpdate: function (e, t) { if (t) { var n = e.getSelectionRange(); e.replaceContent(t.data, t.start, t.end, true); e.createSelection(t.caret, t.caret + n.end - n.start); return true } return false }, detectSyntax: function (t, n) { var r = n || "html"; if (!e("resources").hasSyntax(r)) { r = "html" } if (r == "html" && (this.isStyle(t) || this.isInlineCSS(t))) { r = "css" } return r }, detectProfile: function (t) { var n = t.getSyntax(); var r = e("resources").findItem(n, "profile"); if (r) { return r } switch (n) { case "xml": case "xsl": return "xml"; case "css": if (this.isInlineCSS(t)) { return "line" } break; case "html": var r = e("resources").getVariable("profile"); if (!r) { r = this.isXHTML(t) ? "xhtml" : "html" } return r } return "xhtml" }, isXHTML: function (e) { return e.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1 }, isStyle: function (t) { var n = String(t.getContent()); var r = t.getCaretPos(); var i = e("htmlMatcher").tag(n, r); return i && i.open.name.toLowerCase() == "style" && i.innerRange.cmp(r, "lte", "gte") }, isInlineCSS: function (t) { var n = String(t.getContent()); var r = t.getCaretPos(); var i = e("xmlEditTree").parseFromPosition(n, r, true); if (i) { var s = i.itemFromPosition(r, true); return s && s.name().toLowerCase() == "style" && s.valueRange(true).cmp(r, "lte", "gte") } return false } } }); emmet.define("abbreviationUtils", function (e, t) { return { isSnippet: function (t) { return e("elements").is(t.matchedResource(), "snippet") }, isUnary: function (e) { if (e.children.length || e._text || this.isSnippet(e)) { return false } var t = e.matchedResource(); return t && t.is_empty }, isInline: function (t) { return t.isTextNode() || !t.name() || e("tagName").isInlineLevel(t.name()) }, isBlock: function (e) { return this.isSnippet(e) || !this.isInline(e) }, isSnippet: function (t) { return e("elements").is(t.matchedResource(), "snippet") }, hasTagsInContent: function (t) { return e("utils").matchesTag(t.content) }, hasBlockChildren: function (e) { return this.hasTagsInContent(e) && this.isBlock(e) || t.any(e.children, function (e) { return this.isBlock(e) }, this) }, insertChildContent: function (n, r, i) { i = t.extend({ keepVariable: true, appendIfNoChild: true }, i || {}); var s = false; var o = e("utils"); n = o.replaceVariables(n, function (e, t, u) { var a = e; if (t == "child") { a = o.padString(r, o.getLinePaddingFromPosition(n, u.start)); s = true; if (i.keepVariable) a += e } return a }); if (!s && i.appendIfNoChild) { n += r } return n } } }); emmet.define("base64", function (e, t) { var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; return { encode: function (e) { var t = []; var r, i, s, o, u, a, f, l, c, h; var p = 0, d = e.length, v = n; while (p < d) { l = e.charCodeAt(p++); c = e.charCodeAt(p++); h = e.charCodeAt(p++); r = l & 255; i = c & 255; s = h & 255; o = r >> 2; u = (r & 3) << 4 | i >> 4; a = (i & 15) << 2 | s >> 6; f = s & 63; if (isNaN(c)) { a = f = 64 } else if (isNaN(h)) { f = 64 } t.push(v.charAt(o) + v.charAt(u) + v.charAt(a) + v.charAt(f)) } return t.join("") }, decode: function (e) { var t, r, i, s, o, u, a, f, l = 0, c = 0, h = []; var p = n, d = e.length; if (!e) { return e } e += ""; do { s = p.indexOf(e.charAt(l++)); o = p.indexOf(e.charAt(l++)); u = p.indexOf(e.charAt(l++)); a = p.indexOf(e.charAt(l++)); f = s << 18 | o << 12 | u << 6 | a; t = f >> 16 & 255; r = f >> 8 & 255; i = f & 255; if (u == 64) { h[c++] = String.fromCharCode(t) } else if (a == 64) { h[c++] = String.fromCharCode(t, r) } else { h[c++] = String.fromCharCode(t, r, i) } } while (l < d); return h.join("") } } }); emmet.define("htmlMatcher", function (e, t) { function i(t, n) { return { name: n[1], selfClose: !!n[3], range: e("range").create(t, n[0]), type: "open" } } function s(t, n) { return { name: n[1], range: e("range").create(t, n[0]), type: "close" } } function o(n, r) { return { range: e("range").create(n, t.isNumber(r) ? r - n : r[0]), type: "comment" } } function u(e) { var t = {}, o; return { open: function (e) { var t = this.matches(e); return t && t.type == "open" ? t : null }, close: function (e) { var t = this.matches(e); return t && t.type == "close" ? t : null }, matches: function (u) { var a = "p" + u; if (!(a in t)) { if (e.charAt(u) == "<") { var f = e.slice(u); if (o = f.match(n)) { t[a] = i(u, o) } else if (o = f.match(r)) { t[a] = s(u, o) } else { t[a] = false } } } return t[a] }, text: function () { return e } } } function a(e, t, n) { return e.substring(t, t + n.length) == n } function f(e, n) { var r = [], i = null; var s = n.text(); for (var o = e.range.end, u = s.length; o < u; o++) { if (a(s, o, "<!--")) { for (var f = o; f < u; f++) { if (a(s, f, "-->")) { o = f + 3; break } } } if (i = n.matches(o)) { if (i.type == "open" && !i.selfClose) { r.push(i.name) } else if (i.type == "close") { if (!r.length) { return i.name == e.name ? i : null } if (t.last(r) == i.name) { r.pop() } else { var l = false; while (r.length && !l) { var c = r.pop(); if (c == i.name) { l = true } } if (!r.length && !l) { return i.name == e.name ? i : null } } } } } } var n = /^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/; var r = /^<\/([\w\:\-]+)[^>]*>/; return { find: function (t, n) { var r = e("range"); var i = u(t); var s = null, l = null; for (var c = n; c >= 0; c--) { if (s = i.open(c)) { if (s.selfClose) { if (s.range.cmp(n, "lt", "gt")) { break } continue } l = f(s, i); if (l) { var h = r.create2(s.range.start, l.range.end); if (h.contains(n)) { break } } else if (s.range.contains(n)) { break } s = null } else if (a(t, c, "-->")) { for (var p = c - 1; p >= 0; p--) { if (a(t, p, "-->")) { break } else if (a(t, p, "<!--")) { c = p; break } } } else if (a(t, c, "<!--")) { var p = c + 4, d = t.length; for (; p < d; p++) { if (a(t, p, "-->")) { p += 3; break } } s = o(c, p); break } } if (s) { var v = null; var m = null; if (l) { v = r.create2(s.range.start, l.range.end); m = r.create2(s.range.end, l.range.start) } else { v = m = r.create2(s.range.start, s.range.end) } if (s.type == "comment") { var g = v.substring(t); m.start += g.length - g.replace(/^<\!--\s*/, "").length; m.end -= g.length - g.replace(/\s*-->$/, "").length } return { open: s, close: l, type: s.type == "comment" ? "comment" : "tag", innerRange: m, innerContent: function () { return this.innerRange.substring(t) }, outerRange: v, outerContent: function () { return this.outerRange.substring(t) }, range: !m.length() || !m.cmp(n, "lte", "gte") ? v : m, content: function () { return this.range.substring(t) }, source: t } } }, tag: function (e, t) { var n = this.find(e, t); if (n && n.type == "tag") { return n } } } }); emmet.define("tabStops", function (e, t) { var n = 100; var r = 0; var i = { replaceCarets: false, escape: function (e) { return "\\" + e }, tabstop: function (e) { return e.token }, variable: function (e) { return e.token } }; e("abbreviationParser").addOutputProcessor(function (t, n, i) { var s = 0; var o = e("tabStops"); var u = e("utils"); var a = { tabstop: function (e) { var t = parseInt(e.group); if (t == 0) return "${0}"; if (t > s) s = t; if (e.placeholder) { var n = t + r; var i = o.processText(e.placeholder, a); return "${" + n + ":" + i + "}" } else { return "${" + (t + r) + "}" } } }; t = o.processText(t, a); t = u.replaceVariables(t, o.variablesResolver(n)); r += s + 1; return t }); return { extract: function (n, r) { var s = e("utils"); var o = { carets: "" }; var u = []; r = t.extend({}, i, r, { tabstop: function (e) { var t = e.token; var n = ""; if (e.placeholder == "cursor") { u.push({ start: e.start, end: e.start + t.length, group: "carets", value: "" }) } else { if ("placeholder" in e) o[e.group] = e.placeholder; if (e.group in o) n = o[e.group]; u.push({ start: e.start, end: e.start + t.length, group: e.group, value: n }) } return t } }); if (r.replaceCarets) { n = n.replace(new RegExp(s.escapeForRegexp(s.getCaretPlaceholder()), "g"), "${0:cursor}") } n = this.processText(n, r); var a = s.stringBuilder(), f = 0; var l = t.map(u, function (e) { a.append(n.substring(f, e.start)); var t = a.length; var r = o[e.group] || ""; a.append(r); f = e.end; return { group: e.group, start: t, end: t + r.length } }); a.append(n.substring(f)); return { text: a.toString(), tabstops: t.sortBy(l, "start") } }, processText: function (n, r) { r = t.extend({}, i, r); var s = e("utils").stringBuilder(); var o = e("stringStream").create(n); var u, a, f; while (u = o.next()) { if (u == "\\" && !o.eol()) { s.append(r.escape(o.next())); continue } f = u; if (u == "$") { o.start = o.pos - 1; if (a = o.match(/^[0-9]+/)) { f = r.tabstop({ start: s.length, group: o.current().substr(1), token: o.current() }) } else if (a = o.match(/^\{([a-z_\-][\w\-]*)\}/)) { f = r.variable({ start: s.length, name: a[1], token: o.current() }) } else if (a = o.match(/^\{([0-9]+)(:.+?)?\}/, false)) { o.skipToPair("{", "}"); var l = { start: s.length, group: a[1], token: o.current() }; var c = l.token.substring(l.group.length + 2, l.token.length - 1); if (c) { l.placeholder = c.substr(1) } f = r.tabstop(l) } } s.append(f) } return s.toString() }, upgrade: function (e, n) { var r = 0; var i = { tabstop: function (e) { var t = parseInt(e.group); if (t > r) r = t; if (e.placeholder) return "${" + (t + n) + ":" + e.placeholder + "}"; else return "${" + (t + n) + "}" } }; t.each(["start", "end", "content"], function (t) { e[t] = this.processText(e[t], i) }, this); return r }, variablesResolver: function (r) { var i = {}; var s = e("resources"); return function (o, u) { if (u == "child") return o; if (u == "cursor") return e("utils").getCaretPlaceholder(); var a = r.attribute(u); if (!t.isUndefined(a) && a !== o) { return a } var f = s.getVariable(u); if (f) return f; if (!i[u]) i[u] = n++; return "${" + i[u] + ":" + u + "}" } }, resetTabstopIndex: function () { r = 0; n = 100 } } }); emmet.define("preferences", function (e, t) { function o(e) { if (t.isString(e)) { e = e.toLowerCase(); return e == "yes" || e == "true" || e == "1" } return !!e } function u(e) { return t.isObject(e) && "value" in e && t.keys(e).length < 3 } var n = {}; var r = {}; var i = null; var s = null; return { define: function (e, n, i) { var s = e; if (t.isString(e)) { s = {}; s[e] = { value: n, description: i } } t.each(s, function (e, t) { r[t] = u(e) ? e : { value: e } }) }, set: function (e, i) { var s = e; if (t.isString(e)) { s = {}; s[e] = i } t.each(s, function (e, t) { if (!(t in r)) { throw 'Property "' + t + '" is not defined. You should define it first with `define` method of current module' } if (e !== r[t].value) { switch (typeof r[t].value) { case "boolean": e = o(e); break; case "number": e = parseInt(e + "", 10) || 0; break; default: if (e !== null) { e += "" } } n[t] = e } else if (t in n) { delete n[t] } }) }, get: function (e) { if (e in n) return n[e]; if (e in r) return r[e].value; return void 0 }, getArray: function (n) { var r = this.get(n); if (t.isUndefined(r) || r === null || r === "") { return null } r = t.map(r.split(","), e("utils").trim); if (!r.length) { return null } return r }, getDict: function (e) { var n = {}; t.each(this.getArray(e), function (e) { var t = e.split(":"); n[t[0]] = t[1] }); return n }, description: function (e) { return e in r ? r[e].description : void 0 }, remove: function (e) { if (!t.isArray(e)) e = [e]; t.each(e, function (e) { if (e in n) delete n[e]; if (e in r) delete r[e] }) }, list: function () { return t.map(t.keys(r).sort(), function (e) { return { name: e, value: this.get(e), type: typeof r[e].value, description: r[e].description } }, this) }, load: function (e) { t.each(e, function (e, t) { this.set(t, e) }, this) }, exportModified: function () { return t.clone(n) }, reset: function () { n = {} }, _startTest: function () { i = r; s = n; r = {}; n = {} }, _stopTest: function () { r = i; n = s } } }); emmet.define("filters", function (e, t) { function i(e) { if (!e) return []; if (t.isString(e)) return e.split(/[\|,]/g); return e } var n = {}; var r = "html"; return { add: function (e, t) { n[e] = t }, apply: function (r, s, o) { var u = e("utils"); o = e("profile").get(o); t.each(i(s), function (e) { var t = u.trim(e.toLowerCase()); if (t && t in n) { r = n[t](r, o) } }); return r }, composeList: function (t, n, s) { n = e("profile").get(n); var o = i(n.filters || e("resources").findItem(t, "filters") || r); if (n.extraFilters) { o = o.concat(i(n.extraFilters)) } if (s) { o = o.concat(i(s)) } if (!o || !o.length) { o = i(r) } return o }, extractFromAbbreviation: function (e) { var t = ""; e = e.replace(/\|([\w\|\-]+)$/, function (e, n) { t = n; return "" }); return [e, i(t)] } } }); emmet.define("elements", function (e, t) { function s(e) { return { data: e } } var n = {}; var r = /([\w\-:]+)\s*=\s*(['"])(.*?)\2/g; var i = { add: function (e, t) { var r = this; n[e] = function () { var n = t.apply(r, arguments); if (n) n.type = e; return n } }, get: function (e) { return n[e] }, create: function (e) { var t = [].slice.call(arguments, 1); var n = this.get(e); return n ? n.apply(this, t) : null }, is: function (e, t) { return e && e.type === t } }; i.add("element", function (e, n, i) { var s = { name: e, is_empty: !!i }; if (n) { s.attributes = []; if (t.isArray(n)) { s.attributes = n } else if (t.isString(n)) { var o; while (o = r.exec(n)) { s.attributes.push({ name: o[1], value: o[3] }) } } else { t.each(n, function (e, t) { s.attributes.push({ name: t, value: e }) }) } } return s }); i.add("snippet", s); i.add("reference", s); i.add("empty", function () { return {} }); return i }); emmet.define("editTree", function (e, t, n) { function i(e, n) { this.options = t.extend({ offset: 0 }, n); this.source = e; this._children = []; this._positions = { name: 0 }; this.initialize.apply(this, arguments) } function s(e, t, n) { this.parent = e; this._name = t.value; this._value = n ? n.value : ""; this._positions = { name: t.start, value: n ? n.start : -1 }; this.initialize.apply(this, arguments) } var r = e("range").create; i.extend = n.extend; i.prototype = { initialize: function () { }, _updateSource: function (n, i, s) { var o = r(i, t.isUndefined(s) ? 0 : s - i); var u = n.length - o.length(); var a = function (e) { t.each(e, function (t, n) { if (t >= o.end) e[n] += u }) }; a(this._positions); t.each(this.list(), function (e) { a(e._positions) }); this.source = e("utils").replaceSubstring(this.source, n, o) }, add: function (e, t, n) { var r = new s(e, t); this._children.push(r); return r }, get: function (e) { if (t.isNumber(e)) return this.list()[e]; if (t.isString(e)) return t.find(this.list(), function (t) { return t.name() === e }); return e }, getAll: function (e) { if (!t.isArray(e)) e = [e]; var n = [], r = []; t.each(e, function (e) { if (t.isString(e)) n.push(e); else if (t.isNumber(e)) r.push(e) }); return t.filter(this.list(), function (e, i) { return t.include(r, i) || t.include(n, e.name()) }) }, value: function (e, n, r) { var i = this.get(e); if (i) return i.value(n); if (!t.isUndefined(n)) { return this.add(e, n, r) } }, values: function (e) { return t.map(this.getAll(e), function (e) { return e.value() }) }, remove: function (e) { var n = this.get(e); if (n) { this._updateSource("", n.fullRange()); this._children = t.without(this._children, n) } }, list: function () { return this._children }, indexOf: function (e) { return t.indexOf(this.list(), this.get(e)) }, name: function (e) { if (!t.isUndefined(e) && this._name !== (e = String(e))) { this._updateSource(e, this._positions.name, this._positions.name + this._name.length); this._name = e } return this._name }, nameRange: function (e) { return r(this._positions.name + (e ? this.options.offset : 0), this.name()) }, range: function (e) { return r(e ? this.options.offset : 0, this.toString()) }, itemFromPosition: function (e, n) { return t.find(this.list(), function (t) { return t.range(n).inside(e) }) }, toString: function () { return this.source } }; s.extend = n.extend; s.prototype = { initialize: function () { }, _pos: function (e, t) { return e + (t ? this.parent.options.offset : 0) }, value: function (e) { if (!t.isUndefined(e) && this._value !== (e = String(e))) { this.parent._updateSource(e, this.valueRange()); this._value = e } return this._value }, name: function (e) { if (!t.isUndefined(e) && this._name !== (e = String(e))) { this.parent._updateSource(e, this.nameRange()); this._name = e } return this._name }, namePosition: function (e) { return this._pos(this._positions.name, e) }, valuePosition: function (e) { return this._pos(this._positions.value, e) }, range: function (e) { return r(this.namePosition(e), this.toString()) }, fullRange: function (e) { return this.range(e) }, nameRange: function (e) { return r(this.namePosition(e), this.name()) }, valueRange: function (e) { return r(this.valuePosition(e), this.value()) }, toString: function () { return this.name() + this.value() }, valueOf: function () { return this.toString() } }; return { EditContainer: i, EditElement: s, createToken: function (e, t, n) { var r = { start: e || 0, value: t || "", type: n }; r.end = r.start + r.value.length; return r } } }); emmet.define("cssEditTree", function (e, t) { function s(t, n) { return e("range").create(t, n) } function o(e, n) { n = n || r | i; var s = ["white", "line"]; if ((n & i) == i) while (e.length && t.include(s, t.last(e).type)) { e.pop() } if ((n & r) == r) while (e.length && t.include(s, e[0].type)) { e.shift() } return e } function u(e) { var n = [], r; var i = e.position(), u; while (r = e.next()) { if (r.type == "{") break; n.push(r) } o(n); if (n.length) { i = n[0].start; u = t.last(n).end } else { u = i } return s(i, u - i) } function a(e) { var n = ["white", "line", ":"]; var u = [], a, f, l; e.nextUntil(function (e) { return !t.include(n, this.itemNext().type) }); f = e.current().end; while (a = e.next()) { if (a.type == "}" || a.type == ";") { o(u, r | (a.type == "}" ? i : 0)); if (u.length) { f = u[0].start; l = t.last(u).end } else { l = f } return s(f, l - f) } u.push(a) } if (u.length) { return s(u[0].start, t.last(u).end - u[0].start) } } function f(n) { var r = e("stringStream").create(n); var i; var o = []; var u = /[\s\u00a0,]/; var a = function () { r.next(); o.push(s(r.start, r.current())); r.start = r.pos }; r.eatSpace(); r.start = r.pos; while (i = r.next()) { if (i == '"' || i == "'") { r.next(); if (!r.skipTo(i)) break; a() } else if (i == "(") { r.backUp(1); if (!r.skipToPair("(", ")")) break; r.backUp(1); a() } else { if (u.test(i)) { o.push(s(r.start, r.current().length - 1)); r.eatWhile(u); r.start = r.pos } } } a(); return t.chain(o).filter(function (e) { return !!e.length() }).uniq(false, function (e) { return e.toString() }).value() } function l(e) { var t = e.tokens; for (var n = e._i + 1, r = t.length; n < r; n++) { if (t[n].type == ":") return true; if (t[n].type == "identifier" || t[n].type == "line") return false } return false } var n = { styleBefore: "\n	", styleSeparator: ": ", offset: 0 }; var r = 1; var i = 2; var c = e("editTree").EditContainer.extend({ initialize: function (r, i) { t.defaults(this.options, n); var o = e("editTree"); var f = e("tokenIterator").create(e("cssParser").parse(r)); var c = u(f); this._positions.name = c.start; this._name = c.substring(r); if (!f.current() || f.current().type != "{") throw "Invalid CSS rule"; this._positions.contentStart = f.position() + 1; var p, d, v; while (v = f.next()) { if (v.type == "identifier" && l(f)) { p = s(v); d = a(f); var m = f.current() && f.current().type == ";" ? s(f.current()) : s(d.end, 0); this._children.push(new h(this, o.createToken(p.start, p.substring(r)), o.createToken(d.start, d.substring(r)), o.createToken(m.start, m.substring(r)))) } } this._saveStyle() }, _saveStyle: function () { var n = this._positions.contentStart; var r = this.source; var i = e("utils"); t.each(this.list(), function (e) { e.styleBefore = r.substring(n, e.namePosition()); var s = i.splitByLines(e.styleBefore); if (s.length > 1) { e.styleBefore = "\n" + t.last(s) } e.styleSeparator = r.substring(e.nameRange().end, e.valuePosition()); e.styleBefore = t.last(e.styleBefore.split("*/")); e.styleSeparator = e.styleSeparator.replace(/\/\*.*?\*\//g, ""); n = e.range().end }) }, add: function (n, r, i) { var s = this.list(); var o = this._positions.contentStart; var u = t.pick(this.options, "styleBefore", "styleSeparator"); var a = e("editTree"); if (t.isUndefined(i)) i = s.length; var f = s[i]; if (f) { o = f.fullRange().start } else if (f = s[i - 1]) { f.end(";"); o = f.range().end } if (f) { u = t.pick(f, "styleBefore", "styleSeparator") } var l = a.createToken(o + u.styleBefore.length, n); var c = a.createToken(l.end + u.styleSeparator.length, r); var p = new h(this, l, c, a.createToken(c.end, ";")); t.extend(p, u); this._updateSource(p.styleBefore + p.toString(), o); this._children.splice(i, 0, p); return p } }); var h = e("editTree").EditElement.extend({ initialize: function (e, t, n, r) { this.styleBefore = e.options.styleBefore; this.styleSeparator = e.options.styleSeparator; this._end = r.value; this._positions.end = r.start }, valueParts: function (e) { var n = f(this.value()); if (e) { var r = this.valuePosition(true); t.each(n, function (e) { e.shift(r) }) } return n }, end: function (e) { if (!t.isUndefined(e) && this._end !== e) { this.parent._updateSource(e, this._positions.end, this._positions.end + this._end.length); this._end = e } return this._end }, fullRange: function (e) { var t = this.range(e); t.start -= this.styleBefore.length; return t }, toString: function () { return this.name() + this.styleSeparator + this.value() + this.end() } }); return { parse: function (e, t) { return new c(e, t) }, parseFromPosition: function (e, t, n) { var r = this.extractRule(e, t, n); if (!r || !r.inside(t)) return null; return this.parse(r.substring(e), { offset: r.start }) }, extractRule: function (t, n, r) { var i = ""; var s = t.length; var o = n; var u = "{}/\\<>\n\r"; var a = -1, f; while (o >= 0) { f = t.charAt(o); if (f == "{") { a = o; break } else if (f == "}" && !r) { o++; break } o-- } while (o < s) { f = t.charAt(o); if (f == "{") { a = o } else if (f == "}") { if (a != -1) i = t.substring(a, o + 1); break } o++ } if (i) { o = a - 1; var l = ""; while (o >= 0) { f = t.charAt(o); if (u.indexOf(f) != -1) break; o-- } l = t.substring(o + 1, a).replace(/^[\s\n\r]+/m, ""); return e("range").create(a - l.length, i.length + l.length) } return null }, baseName: function (e) { return e.replace(/^\s*\-\w+\-/, "") }, findParts: f } }); emmet.define("xmlEditTree", function (e, t) { var n = { styleBefore: " ", styleSeparator: "=", styleQuote: '"', offset: 0 }; var r = /^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/m; var i = e("editTree").EditContainer.extend({ initialize: function (r, i) { t.defaults(this.options, n); this._positions.name = 1; var o = null; var u = e("xmlParser").parse(r); var a = e("range"); t.each(u, function (e) { e.value = a.create(e).substring(r); switch (e.type) { case "tag": if (/^<[^\/]+/.test(e.value)) { this._name = e.value.substring(1) } break; case "attribute": if (o) { this._children.push(new s(this, o)) } o = e; break; case "string": this._children.push(new s(this, o, e)); o = null; break } }, this); if (o) { this._children.push(new s(this, o)) } this._saveStyle() }, _saveStyle: function () { var e = this.nameRange().end; var n = this.source; t.each(this.list(), function (t) { t.styleBefore = n.substring(e, t.namePosition()); if (t.valuePosition() !== -1) { t.styleSeparator = n.substring(t.namePosition() + t.name().length, t.valuePosition() - t.styleQuote.length) } e = t.range().end }) }, add: function (n, r, i) { var o = this.list(); var u = this.nameRange().end; var a = e("editTree"); var f = t.pick(this.options, "styleBefore", "styleSeparator", "styleQuote"); if (t.isUndefined(i)) i = o.length; var l = o[i]; if (l) { u = l.fullRange().start } else if (l = o[i - 1]) { u = l.range().end } if (l) { f = t.pick(l, "styleBefore", "styleSeparator", "styleQuote") } r = f.styleQuote + r + f.styleQuote; var c = new s(this, a.createToken(u + f.styleBefore.length, n), a.createToken(u + f.styleBefore.length + n.length + f.styleSeparator.length, r)); t.extend(c, f); this._updateSource(c.styleBefore + c.toString(), u); this._children.splice(i, 0, c); return c } }); var s = e("editTree").EditElement.extend({ initialize: function (e, t, n) { this.styleBefore = e.options.styleBefore; this.styleSeparator = e.options.styleSeparator; var r = "", i = e.options.styleQuote; if (n) { r = n.value; i = r.charAt(0); if (i == '"' || i == "'") { r = r.substring(1) } else { i = "" } if (i && r.charAt(r.length - 1) == i) { r = r.substring(0, r.length - 1) } } this.styleQuote = i; this._value = r; this._positions.value = n ? n.start + i.length : -1 }, fullRange: function (e) { var t = this.range(e); t.start -= this.styleBefore.length; return t }, toString: function () { return this.name() + this.styleSeparator + this.styleQuote + this.value() + this.styleQuote } }); return { parse: function (e, t) { return new i(e, t) }, parseFromPosition: function (e, t, n) { var r = this.extractTag(e, t, n); if (!r || !r.inside(t)) return null; return this.parse(r.substring(e), { offset: r.start }) }, extractTag: function (t, n, i) { var s = t.length, o; var u = e("range"); var a = Math.min(2e3, s); var f = null; var l = function (e) { var n; if (t.charAt(e) == "<" && (n = t.substr(e, a).match(r))) return u.create(e, n[0]) }; for (o = n; o >= 0; o--) { if (f = l(o)) break } if (f && (f.inside(n) || i)) return f; if (!f && i) return null; for (o = n; o < s; o++) { if (f = l(o)) return f } } } }); emmet.define("expandAbbreviation", function (e, t) { var n = e("handlerList").create(); var r = null; var i = e("actions"); i.add("expand_abbreviation", function (r, i, s) { var o = t.toArray(arguments); var u = e("editorUtils").outputInfo(r, i, s); o[1] = u.syntax; o[2] = u.profile; return n.exec(false, o) }); i.add("expand_abbreviation_with_tab", function (t, n, r) { var s = t.getSelection(); var o = e("resources").getVariable("indentation"); if (s) { var u = e("utils"); var a = e("range").create(t.getSelectionRange()); var f = u.padString(s, o); t.replaceContent(o + "${0}", t.getCaretPos()); var l = e("range").create(t.getCaretPos(), a.length()); t.replaceContent(f, l.start, l.end, true); t.createSelection(l.start, l.start + f.length); return true } if (!i.run("expand_abbreviation", t, n, r)) { t.replaceContent(o, t.getCaretPos()) } return true }, { hidden: true }); n.add(function (t, n, i) { var s = t.getSelectionRange().end; var o = r.findAbbreviation(t); if (o) { var u = emmet.expandAbbreviation(o, n, i, e("actionUtils").captureContext(t)); if (u) { t.replaceContent(u, s - o.length, s); return true } } return false }, { order: -1 }); return r = { addHandler: function (e, t) { n.add(e, t) }, removeHandler: function (e) { n.remove(e, options) }, findAbbreviation: function (t) { var n = e("range").create(t.getSelectionRange()); var r = String(t.getContent()); if (n.length()) { return n.substring(r) } var i = t.getCurrentLineRange(); return e("actionUtils").extractAbbreviation(r.substring(i.start, n.start)) } } }); emmet.define("wrapWithAbbreviation", function (e, t) { var n = null; e("actions").add("wrap_with_abbreviation", function (t, r, i, s) { var o = e("editorUtils").outputInfo(t, i, s); var u = e("utils"); var a = e("editorUtils"); r = r || t.prompt("Enter abbreviation"); if (!r) return null; r = String(r); var f = e("range").create(t.getSelectionRange()); if (!f.length()) { var l = e("htmlMatcher").tag(o.content, f.start); if (!l) { return false } f = u.narrowToNonSpace(o.content, l.range) } var c = u.escapeText(f.substring(o.content)); var h = n.wrap(r, a.unindent(t, c), o.syntax, o.profile, e("actionUtils").captureContext(t)); if (h) { t.replaceContent(h, f.start, f.end); return true } return false }); return n = { wrap: function (t, n, r, i, s) { var o = e("filters"); var u = e("utils"); r = r || emmet.defaultSyntax(); i = e("profile").get(i, r); e("tabStops").resetTabstopIndex(); var a = o.extractFromAbbreviation(t); var f = e("abbreviationParser").parse(a[0], { syntax: r, pastedContent: n, contextNode: s }); if (f) { var l = o.composeList(r, i, a[1]); o.apply(f, l, i); return u.replaceVariables(f.toString()) } return null } } }); emmet.exec(function (e, t) { function n(t) { var n = e("range").create(t.getSelectionRange()); var r = e("editorUtils").outputInfo(t); if (!n.length()) { var i = e("htmlMatcher").tag(r.content, t.getCaretPos()); if (i) { n = i.outerRange } } return o(t, "<!--", "-->", n) } function r(t) { var n = e("range").create(t.getSelectionRange()); var r = e("editorUtils").outputInfo(t); if (!n.length()) { var s = e("cssEditTree").parseFromPosition(r.content, t.getCaretPos()); if (s) { var u = i(s, t.getCaretPos()); n = u ? u.range(true) : e("range").create(s.nameRange(true).start, s.source) } } if (!n.length()) { n = e("range").create(t.getCurrentLineRange()); e("utils").narrowToNonSpace(r.content, n) } return o(t, "/*", "*/", n) } function i(e, n) { var r = n - (e.options.offset || 0); var i = /^[\s\n\r]/; return t.find(e.list(), function (t) { if (t.range().end === r) { return i.test(e.source.charAt(r)) } return t.range().inside(r) }) } function s(t, n, r, i) { var s = -1; var o = -1; var u = function (e, n) { return t.substr(n, e.length) == e }; while (n--) { if (u(r, n)) { s = n; break } } if (s != -1) { n = s; var a = t.length; while (a >= n++) { if (u(i, n)) { o = n + i.length; break } } } return s != -1 && o != -1 ? e("range").create(s, o - s) : null } function o(t, n, r, i) { function c(e) { return e.replace(new RegExp("^" + l.escapeForRegexp(n) + "\\s*"), function (e) { a -= e.length; return "" }).replace(new RegExp("\\s*" + l.escapeForRegexp(r) + "$"), "") } var o = e("editorUtils"); var u = o.outputInfo(t).content; var a = t.getCaretPos(); var f = null; var l = e("utils"); var h = s(u, a, n, r); if (h && h.overlap(i)) { i = h; f = c(i.substring(u)) } else { f = n + " " + i.substring(u).replace(new RegExp(l.escapeForRegexp(n) + "\\s*|\\s*" + l.escapeForRegexp(r), "g"), "") + " " + r; a += n.length + 1 } if (f !== null) { f = l.escapeText(f); t.setCaretPos(i.start); t.replaceContent(o.unindent(t, f), i.start, i.end); t.setCaretPos(a); return true } return false } e("actions").add("toggle_comment", function (t) { var i = e("editorUtils").outputInfo(t); if (i.syntax == "css") { var s = t.getCaretPos(); var o = e("htmlMatcher").tag(i.content, s); if (o && o.open.range.inside(s)) { i.syntax = "html" } } if (i.syntax == "css") return r(t); return n(t) }) }); emmet.exec(function (e, t) { function n(e, t, n) { function a(e) { var t = e; while (t >= 0) { var n = i.charAt(t); if (n == "\n" || n == "\r") break; t-- } return i.substring(t, e) } t = t || 1; n = n || 0; var r = e.getCaretPos() + n; var i = String(e.getContent()); var s = i.length; var o = -1; var u = /^\s+$/; while (r <= s && r >= 0) { r += t; var f = i.charAt(r); var l = i.charAt(r + 1); var c = i.charAt(r - 1); switch (f) { case '"': case "'": if (l == f && c == "=") { o = r + 1 } break; case ">": if (l == "<") { o = r + 1 } break; case "\n": case "\r": if (u.test(a(r - 1))) { o = r } break } if (o != -1) break } return o } var r = e("actions"); r.add("prev_edit_point", function (e) { var t = e.getCaretPos(); var r = n(e, -1); if (r == t) r = n(e, -1, -2); if (r != -1) { e.setCaretPos(r); return true } return false }, { label: "Previous Edit Point" }); r.add("next_edit_point", function (e) { var t = n(e, 1); if (t != -1) { e.setCaretPos(t); return true } return false }) }); emmet.exec(function (e, t) { function r(t, n, r, i) { var s = e("range"); var o = e("editorUtils").outputInfo(t).content; var u = o.length; var a, f; var l = s.create(-1, 0); var c = s.create(t.getSelectionRange()); var h = c.start, p = 1e5; while (h >= 0 && h < u && --p > 0) { if (a = r(o, h, n)) { if (l.equal(a)) { break } l = a.clone(); f = i(a.substring(o), a.start, c.clone()); if (f) { t.createSelection(f.start, f.end); return true } else { h = n ? a.start : a.end - 1 } } h += n ? -1 : 1 } return false } function i(e) { var t = true; return r(e, false, function (e, n) { if (t) { t = false; return f(e, n) } else { return l(e, n) } }, function (e, t, n) { return a(e, t, n, false) }) } function s(e) { return r(e, true, l, function (e, t, n) { return a(e, t, n, true) }) } function o(n, r, i) { i = i || 0; var s = e("range"); var o = []; var a = -1, f = "", l = "", h, p; t.each(r, function (e) { switch (e.type) { case "tag": p = n.substring(e.start, e.end); if (/^<[\w\:\-]/.test(p)) { o.push(s.create({ start: e.start + 1, end: e.end })) } break; case "attribute": a = e.start; f = n.substring(e.start, e.end); break; case "string": o.push(s.create(a, e.end - a)); h = s.create(e); l = h.substring(n); if (c(l.charAt(0))) h.start++; if (c(l.charAt(l.length - 1))) h.end--; o.push(h); if (f == "class") { o = o.concat(u(h.substring(n), h.start)) } break } }); t.each(o, function (e) { e.shift(i) }); return t.chain(o).filter(function (e) { return !!e.length() }).uniq(false, function (e) { return e.toString() }).value() } function u(t, n) { n = n || 0; var r = []; var i = e("stringStream").create(t); var s = e("range"); i.eatSpace(); i.start = i.pos; var o; while (o = i.next()) { if (/[\s\u00a0]/.test(o)) { r.push(s.create(i.start + n, i.pos - i.start - 1)); i.eatSpace(); i.start = i.pos } } r.push(s.create(i.start + n, i.pos - i.start)); return r } function a(n, r, i, s) { var u = o(n, e("xmlParser").parse(n), r); if (s) u.reverse(); var a = t.find(u, function (e) { return e.equal(i) }); if (a) { var f = t.indexOf(u, a); if (f < u.length - 1) return u[f + 1]; return null } if (s) return t.find(u, function (e) { return e.start < i.start }); if (!a) { var l = t.filter(u, function (e) { return e.inside(i.end) }); if (l.length > 1) return l[1] } return t.find(u, function (e) { return e.end > i.end }) } function f(e, t) { var n; while (t >= 0) { if (n = l(e, t)) return n; t-- } return null } function l(t, r) { var i; if (t.charAt(r) == "<" && (i = t.substring(r, t.length).match(n))) { return e("range").create(r, i[0]) } } function c(e) { return e == '"' || e == "'" } function h(n) { var r = n.valueRange(true); var i = [n.range(true), r]; var s = e("stringStream"); var o = e("cssEditTree"); var u = e("range"); var a = n.value(); t.each(n.valueParts(), function (e) { var n = e.clone(); i.push(n.shift(r.start)); var f = s.create(e.substring(a)); if (f.match(/^[\w\-]+\(/, true)) { f.start = f.pos; f.skipToPair("(", ")"); var l = f.current(); i.push(u.create(n.start + f.start, l)); t.each(o.findParts(l), function (e) { i.push(u.create(n.start + f.start + e.start, e.substring(l))) }) } }); return t.chain(i).filter(function (e) { return !!e.length() }).uniq(false, function (e) { return e.toString() }).value() } function p(e, n, r) { var i = null; var s, o = null, u; var a = e.list(); var f, l; if (r) { a.reverse(); f = function (e) { return e.range(true).start <= n.start }; l = function (e) { return e.start < n.start } } else { f = function (e) { return e.range(true).end >= n.end }; l = function (e) { return e.end > n.start } } while (i = t.find(a, f)) { s = h(i); if (r) s.reverse(); o = t.find(s, function (e) { return e.equal(n) }); if (!o) { var c = t.filter(s, function (e) { return e.inside(n.end) }); if (c.length > 1) { o = c[1]; break } if (o = t.find(s, l)) break } else { u = t.indexOf(s, o); if (u != s.length - 1) { o = s[u + 1]; break } } o = null; n.start = n.end = r ? i.range(true).start - 1 : i.range(true).end + 1 } return o } function d(t) { return r(t, false, e("cssEditTree").extractRule, m) } function v(t) { return r(t, true, e("cssEditTree").extractRule, g) } function m(t, n, r) { var i = e("cssEditTree").parse(t, { offset: n }); var s = i.nameRange(true); if (r.end < s.end) { return s } return p(i, r, false) } function g(t, n, r) { var i = e("cssEditTree").parse(t, { offset: n }); var s = p(i, r, true); if (!s) { var o = i.nameRange(true); if (r.start > o.start) { return o } } return s } var n = /^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/; var y = e("actions"); y.add("select_next_item", function (e) { if (e.getSyntax() == "css") return d(e); else return i(e) }); y.add("select_previous_item", function (e) { if (e.getSyntax() == "css") return v(e); else return s(e) }) }); emmet.exec(function (e, t) { function s(t, n) { n = String((n || "out").toLowerCase()); var s = e("editorUtils").outputInfo(t); var o = e("range"); var u = o.create(t.getSelectionRange()); var a = s.content; if (i && !i.range.equal(u)) { i = null } if (i && u.length()) { if (n == "in") { if (i.type == "tag" && !i.close) { return false } else { if (i.range.equal(i.outerRange)) { i.range = i.innerRange } else { var f = e("utils").narrowToNonSpace(a, i.innerRange); i = r.find(a, f.start + 1); if (i && i.range.equal(u) && i.outerRange.equal(u)) { i.range = i.innerRange } } } } else { if (!i.innerRange.equal(i.outerRange) && i.range.equal(i.innerRange) && u.equal(i.range)) { i.range = i.outerRange } else { i = r.find(a, u.start); if (i && i.range.equal(u) && i.innerRange.equal(u)) { i.range = i.outerRange } } } } else { i = r.find(a, u.start) } if (i && !i.range.equal(u)) { t.createSelection(i.range.start, i.range.end); return true } i = null; return false } var n = e("actions"); var r = e("htmlMatcher"); var i = null; n.add("match_pair", s, { hidden: true }); n.add("match_pair_inward", function (e) { return s(e, "in") }, { label: "HTML/Match Pair Tag (inward)" }); n.add("match_pair_outward", function (e) { return s(e, "out") }, { label: "HTML/Match Pair Tag (outward)" }); n.add("matching_pair", function (e) { var t = String(e.getContent()); var n = e.getCaretPos(); if (t.charAt(n) == "<") n++; var i = r.tag(t, n); if (i && i.close) { if (i.open.range.inside(n)) { e.setCaretPos(i.close.range.start) } else { e.setCaretPos(i.open.range.start) } return true } return false }, { label: "HTML/Go To Matching Tag Pair" }) }); emmet.exec(function (e, t) { e("actions").add("remove_tag", function (t) { var n = e("utils"); var r = e("editorUtils").outputInfo(t); var i = e("htmlMatcher").tag(r.content, t.getCaretPos()); if (i) { if (!i.close) { t.replaceContent(n.getCaretPlaceholder(), i.range.start, i.range.end) } else { var s = n.narrowToNonSpace(r.content, i.innerRange); var o = n.findNewlineBounds(r.content, s.start); var u = n.getLinePadding(o.substring(r.content)); var a = s.substring(r.content); a = n.unindentString(a, u); t.replaceContent(n.getCaretPlaceholder() + n.escapeText(a), i.outerRange.start, i.outerRange.end) } return true } return false }, { label: "HTML/Remove Tag" }) }); emmet.exec(function (e, t) { function n(t, n, r) { var i = e("utils"); var s = n.selfClosing() || " /"; var o = r.open.range.substring(r.source).replace(/\s*>$/, s + ">"); var u = t.getCaretPos(); if (o.length + r.outerRange.start < u) { u = o.length + r.outerRange.start } o = i.escapeText(o); t.replaceContent(o, r.outerRange.start, r.outerRange.end); t.setCaretPos(u); return true } function r(t, n, r) { var i = e("utils"); var s = i.getNewline(); var o = e("resources").getVariable("indentation"); var u = t.getCaretPos(); var a = n.tag_nl === true ? s + o + s : ""; var f = r.outerContent().replace(/\s*\/>$/, ">"); u = r.outerRange.start + f.length; f += a + "</" + r.open.name + ">"; f = i.escapeText(f); t.replaceContent(f, r.outerRange.start, r.outerRange.end); t.setCaretPos(u); return true } e("actions").add("split_join_tag", function (t, i) { var s = e("htmlMatcher"); var o = e("editorUtils").outputInfo(t, null, i); var u = e("profile").get(o.profile); var a = s.tag(o.content, t.getCaretPos()); if (a) { return a.close ? n(t, u, a) : r(t, u, a) } return false }, { label: "HTML/Split\\Join Tag Declaration" }) }); emmet.define("reflectCSSValue", function (e, t) { function r(t) { var r = e("cssEditTree"); var i = e("editorUtils").outputInfo(t); var s = t.getCaretPos(); var o = r.parseFromPosition(i.content, s); if (!o) return; var u = o.itemFromPosition(s, true); if (!u) return; var a = o.source; var f = o.options.offset; var l = s - f - u.range().start; n.exec(false, [u]); if (a !== o.source) { return { data: o.source, start: f, end: f + a.length, caret: f + u.range().start + l } } } function i(t) { t = e("cssEditTree").baseName(t); var n = "^(?:\\-\\w+\\-)?", r; if (t == "opacity" || t == "filter") { return new RegExp(n + "(?:opacity|filter)$") } else if (r = t.match(/^border-radius-(top|bottom)(left|right)/)) { return new RegExp(n + "(?:" + t + "|border-" + r[1] + "-" + r[2] + "-radius)$") } else if (r = t.match(/^border-(top|bottom)-(left|right)-radius/)) { return new RegExp(n + "(?:" + t + "|border-radius-" + r[1] + r[2] + ")$") } return new RegExp(n + t + "$") } function s(e, t) { var n = o(e.name(), e.value(), t.name(), t.value()); t.value(n) } function o(t, n, r, i) { var s = e("cssEditTree"); var o = e("utils"); t = s.baseName(t); r = s.baseName(r); if (t == "opacity" && r == "filter") { return i.replace(/opacity=[^)]*/i, "opacity=" + Math.floor(parseFloat(n) * 100)) } else if (t == "filter" && r == "opacity") { var u = n.match(/opacity=([^)]*)/i); return u ? o.prettifyNumber(parseInt(u[1]) / 100) : i } return n } var n = e("handlerList").create(); e("actions").add("reflect_css_value", function (t) { if (t.getSyntax() != "css") return false; return e("actionUtils").compoundUpdate(t, r(t)) }, { label: "CSS/Reflect Value" }); n.add(function (e) { var n = i(e.name()); t.each(e.parent.list(), function (t) { if (n.test(t.name())) { s(e, t) } }) }, { order: -1 }); return { addHandler: function (e, t) { n.add(e, t) }, removeHandler: function (e) { n.remove(e, options) } } }); emmet.exec(function (e, t) { e("actions").add("evaluate_math_expression", function (t) { var n = e("actionUtils"); var r = e("utils"); var i = String(t.getContent()); var s = ".+-*/\\"; var o = e("range").create(t.getSelectionRange()); if (!o.length()) { o = n.findExpressionBounds(t, function (e) { return r.isNumeric(e) || s.indexOf(e) != -1 }) } if (o && o.length()) { var u = o.substring(i); u = u.replace(/([\d\.\-]+)\\([\d\.\-]+)/g, "Math.round($1/$2)"); try { var a = r.prettifyNumber((new Function("return " + u))()); t.replaceContent(a, o.start, o.end); t.setCaretPos(o.start + a.length); return true } catch (f) { } } return false }, { label: "Numbers/Evaluate Math Expression" }) }); emmet.exec(function (e, t) { function n(n, i) { var s = e("utils"); var o = e("actionUtils"); var u = false; var a = false; var f = o.findExpressionBounds(n, function (e, t, n) { if (s.isNumeric(e)) return true; if (e == ".") { if (!s.isNumeric(n.charAt(t + 1))) return false; return a ? false : a = true } if (e == "-") return u ? false : u = true; return false }); if (f && f.length()) { var l = f.substring(String(n.getContent())); var c = parseFloat(l); if (!t.isNaN(c)) { c = s.prettifyNumber(c + i); if (/^(\-?)0+[1-9]/.test(l)) { var h = ""; if (RegExp.$1) { h = "-"; c = c.substring(1) } var p = c.split("."); p[0] = s.zeroPadString(p[0], r(l)); c = h + p.join(".") } n.replaceContent(c, f.start, f.end); n.createSelection(f.start, f.start + c.length); return true } } return false } function r(e) { e = e.replace(/^\-/, ""); if (~e.indexOf(".")) { return e.split(".")[0].length } return e.length } var i = e("actions"); t.each([1, -1, 10, -10, .1, -.1], function (e) { var t = e > 0 ? "increment" : "decrement"; i.add(t + "_number_by_" + String(Math.abs(e)).replace(".", "").substring(0, 2), function (t) { return n(t, e) }, { label: "Numbers/" + t.charAt(0).toUpperCase() + t.substring(1) + " number by " + Math.abs(e) }) }) }); emmet.exec(function (e, t) { var n = e("actions"); var r = e("preferences"); r.define("css.closeBraceIndentation", "\n", "Indentation before closing brace of CSS rule. Some users prefere " + "indented closing brace of CSS rule for better readability. " + "This preference’s value will be automatically inserted before " + "closing brace when user adds newline in newly created CSS rule " + "(e.g. when “Insert formatted linebreak” action will be performed " + "in CSS file). If you’re such user, you may want to write put a value " + "like <code>\\n\\t</code> in this preference."); n.add("insert_formatted_line_break_only", function (n) { var i = e("utils"); var s = e("resources"); var o = e("editorUtils").outputInfo(n); var u = n.getCaretPos(); var a = i.getNewline(); if (t.include(["html", "xml", "xsl"], o.syntax)) { var f = s.getVariable("indentation"); var l = e("htmlMatcher").tag(o.content, u); if (l && !l.innerRange.length()) { n.replaceContent(a + f + i.getCaretPlaceholder() + a, u); return true } } else if (o.syntax == "css") { var c = o.content; if (u && c.charAt(u - 1) == "{") { var h = r.get("css.closeBraceIndentation"); var f = s.getVariable("indentation"); var p = c.charAt(u) == "}"; if (!p) { for (var d = u, v = c.length, m; d < v; d++) { m = c.charAt(d); if (m == "{") { break } if (m == "}") { h = ""; p = true; break } } } if (!p) { h += "}" } var g = a + f + i.getCaretPlaceholder() + h; n.replaceContent(g, u); return true } } return false }, { hidden: true }); n.add("insert_formatted_line_break", function (t) { if (!n.run("insert_formatted_line_break_only", t)) { var r = e("utils"); var i = e("editorUtils").getCurrentLinePadding(t); var s = String(t.getContent()); var o = t.getCaretPos(); var u = s.length; var a = r.getNewline(); var f = t.getCurrentLineRange(); var l = ""; for (var c = f.end + 1, h; c < u; c++) { h = s.charAt(c); if (h == " " || h == "	") l += h; else break } if (l.length > i.length) t.replaceContent(a + l, o, o, true); else t.replaceContent(a, o) } return true }, { hidden: true }) }); emmet.exec(function (e, t) { e("actions").add("merge_lines", function (t) { var n = e("htmlMatcher"); var r = e("utils"); var i = e("editorUtils"); var s = i.outputInfo(t); var o = e("range").create(t.getSelectionRange()); if (!o.length()) { var u = n.find(s.content, t.getCaretPos()); if (u) { o = u.outerRange } } if (o.length()) { var a = o.substring(s.content); var f = r.splitByLines(a); for (var l = 1; l < f.length; l++) { f[l] = f[l].replace(/^\s+/, "") } a = f.join("").replace(/\s{2,}/, " "); var c = a.length; a = r.escapeText(a); t.replaceContent(a, o.start, o.end); t.createSelection(o.start, o.start + c); return true } return false }) }); emmet.exec(function (e, t) { function n(e, t, n) { n = n || 0; return t.charAt(n) == e.charAt(0) && t.substr(n, e.length) == e } function r(t, n, r) { var i = e("file"); var s = e("actionUtils"); var o = t.getFilePath(); var u = "application/octet-stream"; if (o === null) { throw "You should save your file before using this action" } var a = i.locateFile(o, n); if (a === null) { throw "Can't find " + n + " file" } i.read(a, function (o, f) { if (o) { throw "Unable to read " + a + ": " + o } var l = e("base64").encode(String(f)); if (!l) { throw "Can't encode file content to base64" } l = "data:" + (s.mimeTypes[String(i.getExt(a))] || u) + ";base64," + l; t.replaceContent("$0" + l, r, r + n.length) }); return true } function i(t, n, r) { var i = String(t.prompt("Enter path to file (absolute or relative)")); if (!i) return false; var s = e("file"); var o = s.createPath(t.getFilePath(), i); if (!o) { throw "Can't save file" } s.save(o, e("base64").decode(n.replace(/^data\:.+?;.+?,/, ""))); t.replaceContent("$0" + i, r, r + n.length); return true } e("actions").add("encode_decode_data_url", function (e) { var t = String(e.getSelection()); var s = e.getCaretPos(); if (!t) { var o = String(e.getContent()), u; while (s-- >= 0) { if (n("src=", o, s)) { if (u = o.substr(s).match(/^(src=(["'])?)([^'"<>\s]+)\1?/)) { t = u[3]; s += u[1].length } break } else if (n("url(", o, s)) { if (u = o.substr(s).match(/^(url\((['"])?)([^'"\)\s]+)\1?/)) { t = u[3]; s += u[1].length } break } } } if (t) { if (n("data:", t)) return i(e, t, s); else return r(e, t, s) } return false }, { label: "Encode\\Decode data:URL image" }) }); emmet.exec(function (e, t) { function n(n) { var r = n.getCaretPos(); var s = e("editorUtils").outputInfo(n); var o = e("xmlEditTree").parseFromPosition(s.content, r, true); if (o && (o.name() || "").toLowerCase() == "img") { i(n, o.value("src"), function (i) { if (i) { var s = o.range(true); o.value("width", i.width); o.value("height", i.height, o.indexOf("width") + 1); e("actionUtils").compoundUpdate(n, t.extend(s, { data: o.toString(), caret: r })) } }) } } function r(n) { var r = n.getCaretPos(); var s = e("editorUtils").outputInfo(n); var o = e("cssEditTree").parseFromPosition(s.content, r, true); if (o) { var u = o.itemFromPosition(r, true), a; if (u && (a = /url\((["']?)(.+?)\1\)/i.exec(u.value() || ""))) { i(n, a[2], function (i) { if (i) { var s = o.range(true); o.value("width", i.width + "px"); o.value("height", i.height + "px", o.indexOf("width") + 1); e("actionUtils").compoundUpdate(n, t.extend(s, { data: o.toString(), caret: r })) } }) } } } function i(t, n, r) { var i; var s = e("actionUtils"); if (n) { if (/^data:/.test(n)) { i = e("base64").decode(n.replace(/^data\:.+?;.+?,/, "")); return r(s.getImageSize(i)) } var o = e("file"); var u = o.locateFile(t.getFilePath(), n); if (u === null) { throw "Can't find " + n + " file" } o.read(u, function (e, t) { if (e) { throw "Unable to read " + u + ": " + e } t = String(t); r(s.getImageSize(t)) }) } } e("actions").add("update_image_size", function (e) { if (t.include(["css", "less", "scss"], String(e.getSyntax()))) { r(e) } else { n(e) } return true }) }); emmet.define("cssResolver", function (e, t) { function l(e) { var t = e && e.charCodeAt(0); return e && e == "." || t > 47 && t < 58 } function c(t) { var n = e("utils"); t = n.trim(t); if (~t.indexOf("/*") || /[\n\r]/.test(t)) { return false } if (!/^[a-z0-9\-]+\s*\:/i.test(t)) { return false } t = e("tabStops").processText(t, { replaceCarets: true, tabstop: function () { return "value" } }); return t.split(":").length == 2 } function h(e) { if (e.charAt(0) == "-" && !/^\-[\.\d]/.test(e)) { e = e.replace(/^\-+/, "") } if (e.charAt(0) == "#") { return p(e) } return d(e) } function p(t) { var n = t.replace(/^#+/, "") || "0"; if (n.toLowerCase() == "t") { return "transparent" } var r = e("utils").repeatString; var i = null; switch (n.length) { case 1: i = r(n, 6); break; case 2: i = r(n, 3); break; case 3: i = n.charAt(0) + n.charAt(0) + n.charAt(1) + n.charAt(1) + n.charAt(2) + n.charAt(2); break; case 4: i = n + n.substr(0, 2); break; case 5: i = n + n.charAt(0); break; default: i = n.substr(0, 6) } if (o.get("css.color.short")) { var s = i.split(""); if (s[0] == s[1] && s[2] == s[3] && s[4] == s[5]) { i = s[0] + s[2] + s[4] } } switch (o.get("css.color.case")) { case "upper": i = i.toUpperCase(); break; case "lower": i = i.toLowerCase(); break } return "#" + i } function d(e) { var t = o.getDict("css.keywordAliases"); return e in t ? t[e] : e } function v(e) { var t = o.getDict("css.unitAliases"); return e in t ? t[e] : e } function m(e) { return t.include(o.getArray("css.keywords"), d(e)) } function g(e, n) { var r = i[n]; if (!r) r = t.find(i, function (e) { return e.prefix == n }); return r && r.supports(e) } function y(e, n) { var r = []; t.each(i, function (t, n) { if (g(e, n)) { r.push(n) } }); if (!r.length && !n) { t.each(i, function (e, t) { if (!e.obsolete) r.push(t) }) } return r } function b(e, n) { if (t.isString(n)) n = { prefix: n }; i[e] = t.extend({}, r, n) } function w(e, n) { if (n) { var r = o.get(n + "." + e); if (!t.isUndefined(r)) return r } return o.get("css." + e) } function E(t, n) { var r = t.indexOf(":"); t = t.substring(0, r).replace(/\s+$/, "") + w("valueSeparator", n) + e("utils").trim(t.substring(r + 1)); return t.replace(/\s*;\s*$/, w("propertyEnd", n)) } function S(e, n, r) { if (!t.isString(e)) e = e.data; if (!c(e)) return e; if (n) { if (~e.indexOf(";")) { e = e.split(";").join(" !important;") } else { e += " !important" } } return E(e, r) } function x(n) { var r = t.map((n || "").split(","), e("utils").trim); return r.length ? r : null } function T(e) { var n = o.getArray(e); t.each(o.getArray(e + "Addon"), function (e) { if (e.charAt(0) == "-") { n = t.without(n, e.substr(1)) } else { if (e.charAt(0) == "+") e = e.substr(1); n.push(e) } }); return n } var n = null; var r = { prefix: "emmet", obsolete: false, transformName: function (e) { return "-" + this.prefix + "-" + e }, properties: function () { return T("css." + this.prefix + "Properties") || [] }, supports: function (e) { return t.include(this.properties(), e) } }; var i = {}; var s = "${1};"; var o = e("preferences"); o.define("css.valueSeparator", ": ", "Defines a symbol that should be placed between CSS property and " + "value when expanding CSS abbreviations."); o.define("css.propertyEnd", ";", "Defines a symbol that should be placed at the end of CSS property  " + "when expanding CSS abbreviations."); o.define("stylus.valueSeparator", " ", "Defines a symbol that should be placed between CSS property and " + "value when expanding CSS abbreviations in Stylus dialect."); o.define("stylus.propertyEnd", "", "Defines a symbol that should be placed at the end of CSS property  " + "when expanding CSS abbreviations in Stylus dialect."); o.define("sass.propertyEnd", "", "Defines a symbol that should be placed at the end of CSS property  " + "when expanding CSS abbreviations in SASS dialect."); o.define("css.autoInsertVendorPrefixes", true, "Automatically generate vendor-prefixed copies of expanded CSS " + "property. By default, Emmet will generate vendor-prefixed " + "properties only when you put dash before abbreviation " + "(e.g. <code>-bxsh</code>). With this option enabled, you don’t " + "need dashes before abbreviations: Emmet will produce " + "vendor-prefixed properties for you."); var u = t.template("A comma-separated list of CSS properties that may have " + "<code><%= vendor %></code> vendor prefix. This list is used to generate " + "a list of prefixed properties when expanding <code>-property</code> " + "abbreviations. Empty list means that all possible CSS values may " + "have <code><%= vendor %></code> prefix."); var a = t.template("A comma-separated list of <em>additional</em> CSS properties " + "for <code>css.<%= vendor %>Preperties</code> preference. " + "You should use this list if you want to add or remove a few CSS " + "properties to original set. To add a new property, simply write its name, " + "to remove it, precede property with hyphen.<br>" + "For example, to add <em>foo</em> property and remove <em>border-radius</em> one, " + "the preference value will look like this: <code>foo, -border-radius</code>."); var f = { webkit: "animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius", moz: "animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius", ms: "accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode", o: "dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style" }; t.each(f, function (e, t) { o.define("css." + t + "Properties", e, u({ vendor: t })); o.define("css." + t + "PropertiesAddon", "", a({ vendor: t })) }); o.define("css.unitlessProperties", "z-index, line-height, opacity, font-weight, zoom", "The list of properties whose values ​​must not contain units."); o.define("css.intUnit", "px", "Default unit for integer values"); o.define("css.floatUnit", "em", "Default unit for float values"); o.define("css.keywords", "auto, inherit", "A comma-separated list of valid keywords that can be used in CSS abbreviations."); o.define("css.keywordAliases", "a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent", "A comma-separated list of keyword aliases, used in CSS abbreviation. " + "Each alias should be defined as <code>alias:keyword_name</code>."); o.define("css.unitAliases", "e:em, p:%, x:ex, r:rem", "A comma-separated list of unit aliases, used in CSS abbreviation. " + "Each alias should be defined as <code>alias:unit_value</code>."); o.define("css.color.short", true, "Should color values like <code>#ffffff</code> be shortened to " + "<code>#fff</code> after abbreviation with color was expanded."); o.define("css.color.case", "keep", "Letter case of color values generated by abbreviations with color " + "(like <code>c#0</code>). Possible values are <code>upper</code>, " + "<code>lower</code> and <code>keep</code>."); o.define("css.fuzzySearch", true, "Enable fuzzy search among CSS snippet names. When enabled, every " + "<em>unknown</em> snippet will be scored against available snippet " + "names (not values or CSS properties!). The match with best score " + "will be used to resolve snippet value. For example, with this " + "preference enabled, the following abbreviations are equal: " + "<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == " + "<code>oh</code>"); o.define("css.fuzzySearchMinScore", .3, "The minium score (from 0 to 1) that fuzzy-matched abbreviation should " + "achive. Lower values may produce many false-positive matches, " + "higher values may reduce possible matches."); o.define("css.alignVendor", false, "If set to <code>true</code>, all generated vendor-prefixed properties " + "will be aligned by real property name."); b("w", { prefix: "webkit" }); b("m", { prefix: "moz" }); b("s", { prefix: "ms" }); b("o", { prefix: "o" }); var N = ["css", "less", "sass", "scss", "stylus"]; e("resources").addResolver(function (e, r) { if (t.include(N, r) && e.isElement()) { return n.expandToSnippet(e.abbreviation, r) } return null }); var C = e("expandAbbreviation"); C.addHandler(function (e, n, r) { if (!t.include(N, n)) { return false } var i = e.getSelectionRange().end; var s = C.findAbbreviation(e); if (s) { var o = emmet.expandAbbreviation(s, n, r); if (o) { var u = i - s.length; var a = i; if (e.getContent().charAt(i) == ";" && o.charAt(o.length - 1) == ";") { a++ } e.replaceContent(o, u, a); return true } } return false }); return n = { addPrefix: b, supportsPrefix: g, prefixed: function (e, t) { return g(e, t) ? "-" + t + "-" + e : e }, listPrefixes: function () { return t.map(i, function (e) { return e.prefix }) }, getPrefix: function (e) { return i[e] }, removePrefix: function (e) { if (e in i) delete i[e] }, extractPrefixes: function (e) { if (e.charAt(0) != "-") { return { property: e, prefixes: null } } var t = 1, n = e.length, r; var s = []; while (t < n) { r = e.charAt(t); if (r == "-") { t++; break } if (r in i) { s.push(r) } else { s.length = 0; t = 1; break } t++ } if (t == n - 1) { t = 1; s.length = 1 } return { property: e.substring(t), prefixes: s.length ? s : "all" } }, findValuesInAbbreviation: function (t, n) { n = n || "css"; var r = 0, i = t.length, s = "", o; while (r < i) { o = t.charAt(r); if (l(o) || o == "#" || o == "-" && l(t.charAt(r + 1))) { s = t.substring(r); break } r++ } var u = t.substring(0, t.length - s.length); var a = e("resources"); var f = []; while (~u.indexOf("-") && !a.findSnippet(n, u)) { var c = u.split("-"); var h = c.pop(); if (!m(h)) { break } f.unshift(h); u = c.join("-") } return f.join("-") + s }, parseValues: function (n) { var r = e("stringStream").create(n); var i = []; var s = null; while (s = r.next()) { if (s == "#") { r.match(/^t|[0-9a-f]+/i, true); i.push(r.current()) } else if (s == "-") { if (m(t.last(i)) || r.start && l(n.charAt(r.start - 1))) { r.start = r.pos } r.match(/^\-?[0-9]*(\.[0-9]+)?[a-z%\.]*/, true); i.push(r.current()) } else { r.match(/^[0-9]*(\.[0-9]*)?[a-z%]*/, true); i.push(r.current()) } r.start = r.pos } return t.map(t.compact(i), h) }, extractValues: function (e) { var t = this.findValuesInAbbreviation(e); if (!t) { return { property: e, values: null } } return { property: e.substring(0, e.length - t.length).replace(/-$/, ""), values: this.parseValues(t) } }, normalizeValue: function (e, n) { n = (n || "").toLowerCase(); var r = o.getArray("css.unitlessProperties"); return e.replace(/^(\-?[0-9\.]+)([a-z]*)$/, function (e, i, s) { if (!s && (i == "0" || t.include(r, n))) return i; if (!s) return i.replace(/\.$/, "") + o.get(~i.indexOf(".") ? "css.floatUnit" : "css.intUnit"); return i + v(s) }) }, expand: function (n, r, u) { u = u || "css"; var a = e("resources"); var f = o.get("css.autoInsertVendorPrefixes"); var l; if (l = /^(.+)\!$/.test(n)) { n = RegExp.$1 } var h = a.findSnippet(u, n); if (h && !f) { return S(h, l, u) } var p = this.extractPrefixes(n); var d = this.extractValues(p.property); var v = t.extend(p, d); if (!h) { h = a.findSnippet(u, v.property) } else { v.values = null } if (!h && o.get("css.fuzzySearch")) { h = a.fuzzyFindSnippet(u, v.property, parseFloat(o.get("css.fuzzySearchMinScore"))) } if (!h) { h = v.property + ":" + s } else if (!t.isString(h)) { h = h.data } if (!c(h)) { return h } var m = this.splitSnippet(h); var g = []; if (!r && v.values) { r = t.map(v.values, function (e) { return this.normalizeValue(e, m.name) }, this).join(" ") + ";" } m.value = r || m.value; var b = v.prefixes == "all" || !v.prefixes && f ? y(m.name, f && v.prefixes != "all") : v.prefixes; var w = [], E; t.each(b, function (e) { if (e in i) { E = i[e].transformName(m.name); w.push(E); g.push(S(E + ":" + m.value, l, u)) } }); g.push(S(m.name + ":" + m.value, l, u)); w.push(m.name); if (o.get("css.alignVendor")) { var x = e("utils").getStringsPads(w); g = t.map(g, function (e, t) { return x[t] + e }) } return g }, expandToSnippet: function (e, n) { var r = this.expand(e, null, n); if (t.isArray(r)) { return r.join("\n") } if (!t.isString(r)) return r.data; return String(r) }, splitSnippet: function (t) { var n = e("utils"); t = n.trim(t); if (t.indexOf(":") == -1) { return { name: t, value: s } } var r = t.split(":"); return { name: n.trim(r.shift()), value: n.trim(r.join(":")).replace(/^(\$\{0\}|\$0)(\s*;?)$/, "${1}$2") } }, getSyntaxPreference: w, transformSnippet: S } }); emmet.define("cssGradient", function (e, t) { function a(t) { return e("utils").trim(t).replace(/\s+/g, " ") } function f(r) { var i = n[0]; var u = e("stringStream").create(e("utils").trim(r)); var f = [], c; while (c = u.next()) { if (u.peek() == ",") { f.push(u.current()); u.next(); u.eatSpace(); u.start = u.pos } else if (c == "(") { u.skipTo(")") } } f.push(u.current()); f = t.compact(t.map(f, a)); if (!f.length) return null; if (s.test(f[0]) || o.test(f[0])) { i = f.shift() } return { type: "linear", direction: i, colorStops: t.map(f, l) } } function l(e) { e = a(e); var t = null; e = e.replace(/^(\w+\(.+?\))\s*/, function (e, n) { t = n; return "" }); if (!t) { var n = e.split(" "); t = n[0]; e = n[1] || "" } var r = { color: t }; if (e) { e.replace(/^(\-?[\d\.]+)([a-z%]+)?$/, function (e, t, n) { r.position = t; if (~t.indexOf(".")) { n = "" } else if (!n) { n = "%" } if (n) r.unit = n }) } return r } function c(n, r) { var i = e("resources"); var s = e("preferences"); var o = i.findSnippet(r, n); if (!o && s.get("css.fuzzySearch")) { o = i.fuzzyFindSnippet(r, n, parseFloat(s.get("css.fuzzySearchMinScore"))) } if (o) { if (!t.isString(o)) { o = o.data } return e("cssResolver").splitSnippet(o).name } } function h(e) { var n = 0; t.each(e, function (r, i) { if (!i) return r.position = r.position || 0; if (i == e.length - 1 && !("position" in r)) r.position = 1; if ("position" in r) { var s = e[n].position || 0; var o = (r.position - s) / (i - n); t.each(e.slice(n, i), function (e, t) { e.position = s + o * t }); n = i } }) } function p(e) { var n = parseFloat(e); if (!t.isNaN(n)) { switch (n % 360) { case 0: return "left"; case 90: return "bottom"; case 180: return "right"; case 240: return "top" } } return e } function d(e) { e = p(e); if (s.test(e)) throw "The direction is an angle that can’t be converted."; var t = function (t) { return ~e.indexOf(t) ? "100%" : "0" }; return t("right") + " " + t("bottom") + ", " + t("left") + " " + t("top") } function v(e) { var n = u.getArray("css.gradient.prefixes"); var r = n ? t.map(n, function (t) { return "-" + t + "-" + e }) : []; r.push(e); return r } function m(n, i) { var s = []; var o = e("cssResolver"); if (u.get("css.gradient.fallback") && ~i.toLowerCase().indexOf("background")) { s.push({ name: "background-color", value: "${1:" + n.colorStops[0].color + "}" }) } t.each(u.getArray("css.gradient.prefixes"), function (e) { var t = o.prefixed(i, e); if (e == "webkit" && u.get("css.gradient.oldWebkit")) { try { s.push({ name: t, value: r.oldWebkitLinearGradient(n) }) } catch (a) { } } s.push({ name: t, value: r.toString(n, e) }) }); return s.sort(function (e, t) { return t.name.length - e.name.length }) } function g(n, i, s) { var o = n.parent; var u = e("utils"); var a = e("preferences").get("css.alignVendor"); var f = n.styleSeparator; var l = n.styleBefore; t.each(o.getAll(v(n.name())), function (e) { if (e != n && /gradient/i.test(e.value())) { if (e.styleSeparator.length < f.length) { f = e.styleSeparator } if (e.styleBefore.length < l.length) { l = e.styleBefore } o.remove(e) } }); if (a) { if (l != n.styleBefore) { var c = n.fullRange(); o._updateSource(l, c.start, c.start + n.styleBefore.length); n.styleBefore = l } if (f != n.styleSeparator) { o._updateSource(f, n.nameRange().end, n.valueRange().start); n.styleSeparator = f } } var h = n.value(); if (!s) s = e("range").create(0, n.value()); var p = function (e) { return u.replaceSubstring(h, e, s) }; n.value(p(r.toString(i)) + "${2}"); var d = m(i, n.name()); if (a) { var g = t.pluck(d, "value"); var y = t.pluck(d, "name"); g.push(n.value()); y.push(n.name()); var b = u.getStringsPads(t.map(g, function (e) { return e.substring(0, e.indexOf("(")) })); var w = u.getStringsPads(y); n.name(t.last(w) + n.name()); t.each(d, function (e, t) { e.name = w[t] + e.name; e.value = b[t] + e.value }); n.value(t.last(b) + n.value()) } t.each(d, function (e) { o.add(e.name, e.value, o.indexOf(n)) }) } function y(e) { var n = e.value(); var i = null; var s = t.find(e.valueParts(), function (e) { return i = r.parse(e.substring(n)) }); if (s && i) { return { gradient: i, valueRange: s } } return null } function b(n, i) { var s = u.get("css.gradient.defaultProperty"); if (!s) return false; var o = String(n.getContent()); var a = e("range").create(n.getCurrentLineRange()); var f = a.substring(o).replace(/^\s+/, function (e) { a.start += e.length; return "" }).replace(/\s+$/, function (e) { a.end -= e.length; return "" }); var l = e("cssResolver"); var c = r.parse(f); if (c) { var h = m(c, s); h.push({ name: s, value: r.toString(c) + "${2}" }); var p = l.getSyntaxPreference("valueSeparator", i); var d = l.getSyntaxPreference("propertyEnd", i); if (e("preferences").get("css.alignVendor")) { var v = e("utils").getStringsPads(t.map(h, function (e) { return e.value.substring(0, e.value.indexOf("(")) })); t.each(h, function (e, t) { e.value = v[t] + e.value }) } h = t.map(h, function (e) { return e.name + p + e.value + d }); n.replaceContent(h.join("\n"), a.start, a.end); return true } return false } function w(n, r) { var i = null; var s = e("cssEditTree").parseFromPosition(n, r, true); if (s) { i = s.itemFromPosition(r, true); if (!i) { i = t.find(s.list(), function (e) { return e.range(true).end == r }) } } return { rule: s, property: i } } var n = ["top", "to bottom", "0deg"]; var r = null; var i = ["css", "less", "sass", "scss", "stylus", "styl"]; var s = /\d+deg/i; var o = /top|bottom|left|right/i; var u = e("preferences"); u.define("css.gradient.prefixes", "webkit, moz, o", "A comma-separated list of vendor-prefixes for which values should " + "be generated."); u.define("css.gradient.oldWebkit", true, "Generate gradient definition for old Webkit implementations"); u.define("css.gradient.omitDefaultDirection", true, "Do not output default direction definition in generated gradients."); u.define("css.gradient.defaultProperty", "background-image", "When gradient expanded outside CSS value context, it will produce " + "properties with this name."); u.define("css.gradient.fallback", false, "With this option enabled, CSS gradient generator will produce " + "<code>background-color</code> property with gradient first color " + "as fallback for old browsers."); e("expandAbbreviation").addHandler(function (n, r, s) { var o = e("editorUtils").outputInfo(n, r, s); if (!t.include(i, o.syntax)) return false; var u = n.getCaretPos(); var a = o.content; var f = w(a, u); if (f.property) { var l = y(f.property); if (l) { var h = f.rule.options.offset || 0; var p = h + f.rule.toString().length; if (/[\n\r]/.test(f.property.value())) { var d = f.property.valueRange(true).start + l.valueRange.end; a = e("utils").replaceSubstring(a, ";", d); var v = w(a, u); if (v.property) { l = y(v.property); f = v } } f.property.end(";"); var m = c(f.property.name(), r); if (m) { f.property.name(m) } g(f.property, l.gradient, l.valueRange); n.replaceContent(f.rule.toString(), h, p, true); return true } } return b(n, r) }); e("reflectCSSValue").addHandler(function (n) { var i = e("utils"); var s = y(n); if (!s) return false; var o = n.value(); var u = function (e) { return i.replaceSubstring(o, e, s.valueRange) }; t.each(n.parent.getAll(v(n.name())), function (e) { if (e === n) return; var t = e.value().match(/^\s*(\-([a-z]+)\-)?linear\-gradient/); if (t) { e.value(u(r.toString(s.gradient, t[2] || ""))) } else if (t = e.value().match(/\s*\-webkit\-gradient/)) { e.value(u(r.oldWebkitLinearGradient(s.gradient))) } }); return true }); return r = { parse: function (t) { var n = null; e("utils").trim(t).replace(/^([\w\-]+)\((.+?)\)$/, function (e, t, r) { t = t.toLowerCase().replace(/^\-[a-z]+\-/, ""); if (t == "linear-gradient" || t == "lg") { n = f(r); return "" } return e }); return n }, oldWebkitLinearGradient: function (e) { if (t.isString(e)) e = this.parse(e); if (!e) return null; var n = t.map(e.colorStops, t.clone); t.each(n, function (e) { if (!("position" in e)) return; if (~e.position.indexOf(".") || e.unit == "%") { e.position = parseFloat(e.position) / (e.unit == "%" ? 100 : 1) } else { throw "Can't convert color stop '" + (e.position + (e.unit || "")) + "'" } }); h(n); n = t.map(n, function (e, t) { if (!e.position && !t) return "from(" + e.color + ")"; if (e.position == 1 && t == n.length - 1) return "to(" + e.color + ")"; return "color-stop(" + e.position.toFixed(2).replace(/\.?0+$/, "") + ", " + e.color + ")" }); return "-webkit-gradient(linear, " + d(e.direction) + ", " + n.join(", ") + ")" }, toString: function (e, r) { if (e.type == "linear") { var i = (r ? "-" + r + "-" : "") + "linear-gradient"; var s = t.map(e.colorStops, function (e) { return e.color + ("position" in e ? " " + e.position + (e.unit || "") : "") }); if (e.direction && (!u.get("css.gradient.omitDefaultDirection") || !t.include(n, e.direction))) { s.unshift(e.direction) } return i + "(" + s.join(", ") + ")" } } } }); emmet.exec(function (e, t) { var n = e("handlerList").create(); var r = e("resources"); t.extend(r, { addGenerator: function (e, r, i) { if (t.isString(e)) e = new RegExp(e); n.add(function (t, n) { var i; if (i = e.exec(t.name())) { return r(i, t, n) } return null }, i) } }); r.addResolver(function (e, r) { return n.exec(null, t.toArray(arguments)) }) }); emmet.define("tagName", function (e, t) { var n = { empty: [], blockLevel: "address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6".split(","), inlineLevel: "a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var".split(",") }; var r = { p: "span", ul: "li", ol: "li", table: "tr", tr: "td", tbody: "tr", thead: "tr", tfoot: "tr", colgroup: "col", select: "option", optgroup: "option", audio: "source", video: "source", object: "param", map: "area" }; return { resolve: function (e) { e = (e || "").toLowerCase(); if (e in r) return this.getMapping(e); if (this.isInlineLevel(e)) return "span"; return "div" }, getMapping: function (e) { return r[e.toLowerCase()] }, isInlineLevel: function (e) { return this.isTypeOf(e, "inlineLevel") }, isBlockLevel: function (e) { return this.isTypeOf(e, "blockLevel") }, isEmptyElement: function (e) { return this.isTypeOf(e, "empty") }, isTypeOf: function (e, r) { return t.include(n[r], e) }, addMapping: function (e, t) { r[e] = t }, removeMapping: function (e) { if (e in r) delete r[e] }, addElementToCollection: function (e, r) { if (!n[r]) n[r] = []; var i = this.getCollection(r); if (!t.include(i, e)) i.push(e) }, removeElementFromCollection: function (e, r) { if (r in n) { n[r] = t.without(this.getCollection(r), e) } }, getCollection: function (e) { return n[e] } } }); emmet.exec(function (e, t) { function i() { return { element: n.get("bem.elementSeparator"), modifier: n.get("bem.modifierSeparator") } } function s(n) { if (e("abbreviationUtils").isSnippet(n)) return n; n.__bem = { block: "", element: "", modifier: "" }; var r = o(n.attribute("class")).split(" "); var i = /^[a-z]\-/i; n.__bem.block = t.find(r, function (e) { return i.test(e) }); if (!n.__bem.block) { i = /^[a-z]/i; n.__bem.block = t.find(r, function (e) { return i.test(e) }) || "" } r = t.chain(r).map(function (e) { return u(e, n) }).flatten().uniq().value().join(" "); if (r) n.attribute("class", r); return n } function o(t) { var r = e("utils"); t = (" " + (t || "") + " ").replace(/\s+/g, " "); var s = n.get("bem.shortElementPrefix"); if (s) { var o = new RegExp("\\s(" + r.escapeForRegexp(s) + "+)", "g"); t = t.replace(o, function (e, t) { return " " + r.repeatString(i().element, t.length) }) } return r.trim(t) } function u(e, t) { e = a(e, t, "element"); e = a(e, t, "modifier"); var n = "", r = "", s = ""; var o = i(); if (~e.indexOf(o.element)) { var u = e.split(o.element); var f = u[1].split(o.modifier); n = u[0]; r = f.shift(); s = f.join(o.modifier) } else if (~e.indexOf(o.modifier)) { var l = e.split(o.modifier); n = l.shift(); s = l.join(o.modifier) } if (n || r || s) { if (!n) { n = t.__bem.block } var c = n; var h = []; if (r) { c += o.element + r; h.push(c) } else { h.push(c) } if (s) { h.push(c + o.modifier + s) } t.__bem.block = n; t.__bem.element = r; t.__bem.modifier = s; return h } return e } function a(e, t, n) { var r = i(); var s = new RegExp("^(" + r[n] + ")+", "g"); if (s.test(e)) { var o = 0; var u = e.replace(s, function (e, t) { o = e.length / r[n].length; return "" }); var a = t; while (a.parent && o--) { a = a.parent } if (!a || !a.__bem) a = t; if (a && a.__bem) { var f = a.__bem.block; if (n == "modifier" && a.__bem.element) f += r.element + a.__bem.element; return f + r[n] + u } } return e } function f(n, i) { if (n.name) s(n, i); var o = e("abbreviationUtils"); t.each(n.children, function (e) { f(e, i); if (!o.isSnippet(e) && e.start) r = true }); return n } var n = e("preferences"); n.define("bem.elementSeparator", "__", "Class name’s element separator."); n.define("bem.modifierSeparator", "_", "Class name’s modifier separator."); n.define("bem.shortElementPrefix", "-", "Symbol for describing short “block-element” notation. Class names " + "prefixed with this symbol will be treated as element name for parent‘s " + "block name. Each symbol instance traverses one level up in parsed " + "tree for block name lookup. Empty value will disable short notation."); var r = false; e("filters").add("bem", function (t, n) { r = false; t = f(t, n); if (r) { t = e("filters").apply(t, "html", n) } return t }) }); emmet.exec(function (e, t) { function r(r, i, s) { var o = e("utils"); var u = n.get("filter.commentTrigger"); if (u != "*") { var a = t.find(u.split(","), function (e) { return !!r.attribute(o.trim(e)) }); if (!a) return } var f = { node: r, name: r.name(), padding: r.parent ? r.parent.padding : "", attr: function (e, t, n) { var i = r.attribute(e); if (i) { return (t || "") + i + (n || "") } return "" } }; var l = o.normalizeNewline(i ? i(f) : ""); var c = o.normalizeNewline(s ? s(f) : ""); r.start = r.start.replace(/</, l + "<"); r.end = r.end.replace(/>/, ">" + c) } function i(n, s, o) { var u = e("abbreviationUtils"); t.each(n.children, function (e) { if (u.isBlock(e)) r(e, s, o); i(e, s, o) }); return n } var n = e("preferences"); n.define("filter.commentAfter", '\n<!-- /<%= attr("id", "#") %><%= attr("class", ".") %> -->', "A definition of comment that should be placed <i>after</i> matched " + "element when <code>comment</code> filter is applied. This definition " + "is an ERB-style template passed to <code>_.template()</code> " + "function (see Underscore.js docs for details). In template context, " + "the following properties and functions are availabe:\n" + "<ul>" + "<li><code>attr(name, before, after)</code> – a function that outputs" + "specified attribute value concatenated with <code>before</code> " + "and <code>after</code> strings. If attribute doesn't exists, the " + "empty string will be returned.</li>" + "<li><code>node</code> – current node (instance of <code>AbbreviationNode</code>)</li>" + "<li><code>name</code> – name of current tag</li>" + "<li><code>padding</code> – current string padding, can be used " + "for formatting</li>" + "</ul>"); n.define("filter.commentBefore", "", "A definition of comment that should be placed <i>before</i> matched " + "element when <code>comment</code> filter is applied. " + "For more info, read description of <code>filter.commentAfter</code> " + "property"); n.define("filter.commentTrigger", "id, class", "A comma-separated list of attribute names that should exist in abbreviatoin " + "where comment should be added. If you wish to add comment for " + "every element, set this option to <code>*</code>"); e("filters").add("c", function (e) { var r = t.template(n.get("filter.commentBefore")); var s = t.template(n.get("filter.commentAfter")); return i(e, r, s) }) }); emmet.exec(function (e, t) { function r(e) { return e.replace(/([<>&])/g, function (e, t) { return n[t] }) } var n = { "<": "&lt;", ">": "&gt;", "&": "&" }; e("filters").add("e", function i(e) { t.each(e.children, function (e) { e.start = r(e.start); e.end = r(e.end); e.content = r(e.content); i(e) }); return e }) }); emmet.exec(function (e, t) { function i(n) { if (t.include(r.getArray("format.noIndentTags") || [], n.name())) { return "" } return e("resources").getVariable("indentation") } function s(t) { return t.parent && e("abbreviationUtils").hasBlockChildren(t.parent) } function o(e) { return e.parent && !e.parent.parent && !e.index() } function u(t, n) { var r = e("abbreviationUtils"); if (n.tag_nl === true || r.isBlock(t)) return true; if (!t.parent || !n.inline_break) return false; return f(t.parent, n) } function a(e, t) { return e.children.length && u(e.children[0], t) } function f(n, r) { var i = 0; var s = e("abbreviationUtils"); return !!t.find(n.children, function (e) { if (e.isTextNode() || !s.isInline(e)) i = 0; else if (s.isInline(e)) i++; if (i >= r.inline_break) return true }) } function l(e) { return !e.parent } function c(t, n, r) { t.start = t.end = ""; if (!o(t) && n.tag_nl !== false && u(t, n)) { if (l(t.parent) || !e("abbreviationUtils").isInline(t.parent)) { t.start = e("utils").getNewline() + t.start } } return t } function h(n, r) { var i = e("abbreviationUtils"); var s = t.any(n.children, function (e) { if (i.isSnippet(e)) return false; return !i.isInline(e) }); if (!s) { return f(n, r) } return true } function p(f, l, c) { f.start = f.end = n; var p = e("utils"); var d = e("abbreviationUtils"); var v = d.isUnary(f); var m = p.getNewline(); var g = i(f); if (l.tag_nl !== false) { var y = l.tag_nl === true && (l.tag_nl_leaf || f.children.length); if (!y) { y = t.include(r.getArray("format.forceIndentationForTags") || [], f.name()) } if (!f.isTextNode()) { if (u(f, l)) { if (!o(f) && (!d.isSnippet(f.parent) || f.index())) f.start = m + f.start; if (d.hasBlockChildren(f) || a(f, l) || y && !v) f.end = m + f.end; if (d.hasTagsInContent(f) || y && !f.children.length && !v) f.start += m + g } else if (d.isInline(f) && s(f) && !o(f)) { f.start = m + f.start } else if (d.isInline(f) && h(f, l)) { f.end = m + f.end } f.padding = g } } return f } var n = "%s"; var r = e("preferences"); r.define("format.noIndentTags", "html", "A comma-separated list of tag names that should not get inner indentation."); r.define("format.forceIndentationForTags", "body", "A comma-separated list of tag names that should <em>always</em> get inner indentation."); e("filters").add("_format", function d(n, r, i) { i = i || 0; var s = e("abbreviationUtils"); t.each(n.children, function (e) { if (s.isSnippet(e)) c(e, r, i); else p(e, r, i); d(e, r, i + 1) }); return n }) }); emmet.exec(function (e, t) { function r(t) { return e("utils").trim(t).replace(/\s+/g, ".") } function i(e, n) { var i = ""; var s = []; var o = n.attributeQuote(); var u = n.cursor(); t.each(e.attributeList(), function (e) { var t = n.attributeName(e.name); switch (t.toLowerCase()) { case "id": i += "#" + (e.value || u); break; case "class": i += "." + r(e.value || u); break; default: s.push(":" + t + " => " + o + (e.value || u) + o) } }); if (s.length) i += "{" + s.join(", ") + "}"; return i } function s(e) { return e.parent && e.parent.hasBlockChildren() } function o(t, n, r) { if (!t.parent) return t; var s = e("abbreviationUtils"); var o = e("utils"); var u = i(t, n); var a = n.cursor(); var f = s.isUnary(t); var l = n.self_closing_tag && f ? "/" : ""; var c = ""; var h = "%" + n.tagName(t.name()); if (h.toLowerCase() == "%div" && u && u.indexOf("{") == -1) h = ""; t.end = ""; c = h + u + l + " "; var p = "%s"; t.start = o.replaceSubstring(t.start, c, t.start.indexOf(p), p); if (!t.children.length && !f) t.start += a; return t } var n = "${child}"; e("filters").add("haml", function u(n, r, i) { i = i || 0; var s = e("abbreviationUtils"); if (!i) { n = e("filters").apply(n, "_format", r) } t.each(n.children, function (e) { if (!s.isSnippet(e)) o(e, r, i); u(e, r, i + 1) }); return n }) }); emmet.exec(function (e, t) { function n(e, n) { var r = n.attributeQuote(); var i = n.cursor(); return t.map(e.attributeList(), function (e) { var t = n.attributeName(e.name); return " " + t + "=" + r + (e.value || i) + r }).join("") } function r(t, r, i) { if (!t.parent) return t; var s = e("abbreviationUtils"); var o = e("utils"); var u = n(t, r); var a = r.cursor(); var f = s.isUnary(t); var l = ""; var c = ""; if (!t.isTextNode()) { var h = r.tagName(t.name()); if (f) { l = "<" + h + u + r.selfClosing() + ">"; t.end = "" } else { l = "<" + h + u + ">"; c = "</" + h + ">" } } var p = "%s"; t.start = o.replaceSubstring(t.start, l, t.start.indexOf(p), p); t.end = o.replaceSubstring(t.end, c, t.end.indexOf(p), p); if (!t.children.length && !f && !~t.content.indexOf(a) && !e("tabStops").extract(t.content).tabstops.length) { t.start += a } return t } e("filters").add("html", function i(n, s, o) { o = o || 0; var u = e("abbreviationUtils"); if (!o) { n = e("filters").apply(n, "_format", s) } t.each(n.children, function (e) { if (!u.isSnippet(e)) r(e, s, o); i(e, s, o + 1) }); return n }) }); emmet.exec(function (e, t) { var n = /^\s+/; var r = /[\n\r]/g; e("filters").add("s", function i(s, o, u) { var a = e("abbreviationUtils"); t.each(s.children, function (e) { if (!a.isSnippet(e)) { e.start = e.start.replace(n, ""); e.end = e.end.replace(n, "") } e.start = e.start.replace(r, ""); e.end = e.end.replace(r, ""); e.content = e.content.replace(r, ""); i(e) }); return s }) }); emmet.exec(function (e, t) { function n(e, r) { t.each(e.children, function (e) { if (e.content) e.content = e.content.replace(r, ""); n(e, r) }); return e } e("preferences").define("filter.trimRegexp", "[\\s|\\u00a0]*[\\d|#|\\-|*|\\u2022]+\\.?\\s*", "Regular expression used to remove list markers (numbers, dashes, " + "bullets, etc.) in <code>t</code> (trim) filter. The trim filter " + "is useful for wrapping with abbreviation lists, pased from other " + "documents (for example, Word documents)."); e("filters").add("t", function (t) { var r = new RegExp(e("preferences").get("filter.trimRegexp")); return n(t, r) }) }); emmet.exec(function (e, t) { function r(e) { e.start = e.start.replace(/\s+select\s*=\s*(['"]).*?\1/, "") } var n = { "xsl:variable": 1, "xsl:with-param": 1 }; e("filters").add("xsl", function i(s) { var o = e("abbreviationUtils"); t.each(s.children, function (e) { if (!o.isSnippet(e) && (e.name() || "").toLowerCase() in n && e.children.length) r(e); i(e) }); return s }) }); emmet.define("lorem", function (e, t) { function i(e, t) { return Math.round(Math.random() * (t - e) + e) } function s(e, n) { var r = e.length; var s = Math.min(r, n); var o = []; while (o.length < s) { var u = i(0, r - 1); if (!t.include(o, u)) o.push(u) } return t.map(o, function (t) { return e[t] }) } function o(e) { if (t.isString(e)) return e.charAt(i(0, e.length - 1)); return e[i(0, e.length - 1)] } function u(e, t) { if (e.length) { e[0] = e[0].charAt(0).toUpperCase() + e[0].substring(1) } return e.join(" ") + (t || o("?!...")) } function a(e) { var n = e.length; var r = 0; if (n > 3 && n <= 6) { r = i(0, 1) } else if (n > 6 && n <= 12) { r = i(0, 2) } else { r = i(1, 4) } t.each(t.range(r), function (t) { if (t < e.length - 1) { e[t] += "," } }) } function f(e, t, r) { var o = n[e]; if (!o) { return "" } var f = []; var l = 0; var c; t = parseInt(t, 10); if (r && o.common) { c = o.common.slice(0, t); if (c.length > 5) c[4] += ","; l += c.length; f.push(u(c, ".")) } while (l < t) { c = s(o.words, Math.min(i(3, 12) * i(1, 5), t - l)); l += c.length; a(c); f.push(u(c)) } return f.join(" ") } var n = { en: { common: ["lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipisicing", "elit"], words: ["exercitationem", "perferendis", "perspiciatis", "laborum", "eveniet", "sunt", "iure", "nam", "nobis", "eum", "cum", "officiis", "excepturi", "odio", "consectetur", "quasi", "aut", "quisquam", "vel", "eligendi", "itaque", "non", "odit", "tempore", "quaerat", "dignissimos", "facilis", "neque", "nihil", "expedita", "vitae", "vero", "ipsum", "nisi", "animi", "cumque", "pariatur", "velit", "modi", "natus", "iusto", "eaque", "sequi", "illo", "sed", "ex", "et", "voluptatibus", "tempora", "veritatis", "ratione", "assumenda", "incidunt", "nostrum", "placeat", "aliquid", "fuga", "provident", "praesentium", "rem", "necessitatibus", "suscipit", "adipisci", "quidem", "possimus", "voluptas", "debitis", "sint", "accusantium", "unde", "sapiente", "voluptate", "qui", "aspernatur", "laudantium", "soluta", "amet", "quo", "aliquam", "saepe", "culpa", "libero", "ipsa", "dicta", "reiciendis", "nesciunt", "doloribus", "autem", "impedit", "minima", "maiores", "repudiandae", "ipsam", "obcaecati", "ullam", "enim", "totam", "delectus", "ducimus", "quis", "voluptates", "dolores", "molestiae", "harum", "dolorem", "quia", "voluptatem", "molestias", "magni", "distinctio", "omnis", "illum", "dolorum", "voluptatum", "ea", "quas", "quam", "corporis", "quae", "blanditiis", "atque", "deserunt", "laboriosam", "earum", "consequuntur", "hic", "cupiditate", "quibusdam", "accusamus", "ut", "rerum", "error", "minus", "eius", "ab", "ad", "nemo", "fugit", "officia", "at", "in", "id", "quos", "reprehenderit", "numquam", "iste", "fugiat", "sit", "inventore", "beatae", "repellendus", "magnam", "recusandae", "quod", "explicabo", "doloremque", "aperiam", "consequatur", "asperiores", "commodi", "optio", "dolor", "labore", "temporibus", "repellat", "veniam", "architecto", "est", "esse", "mollitia", "nulla", "a", "similique", "eos", "alias", "dolore", "tenetur", "deleniti", "porro", "facere", "maxime", "corrupti"] }, ru: { common: ["далеко-далеко", "за", "словесными", "горами", "в стране", "гласных", "и согласных", "живут", "рыбные", "тексты"], words: ["вдали", "от всех", "они", "буквенных", "домах", "на берегу", "семантика", "большого", "языкового", "океана", "маленький", "ручеек", "даль", "журчит", "по всей", "обеспечивает", "ее", "всеми", "необходимыми", "правилами", "эта", "парадигматическая", "страна", "которой", "жаренные", "предложения", "залетают", "прямо", "рот", "даже", "всемогущая", "пунктуация", "не", "имеет", "власти", "над", "рыбными", "текстами", "ведущими", "безорфографичный", "образ", "жизни", "однажды", "одна", "маленькая", "строчка", "рыбного", "текста", "имени", "lorem", "ipsum", "решила", "выйти", "большой", "мир", "грамматики", "великий", "оксмокс", "предупреждал", "о", "злых", "запятых", "диких", "знаках", "вопроса", "коварных", "точках", "запятой", "но", "текст", "дал", "сбить", "себя", "толку", "он", "собрал", "семь", "своих", "заглавных", "букв", "подпоясал", "инициал", "за", "пояс", "пустился", "дорогу", "взобравшись", "первую", "вершину", "курсивных", "гор", "бросил", "последний", "взгляд", "назад", "силуэт", "своего", "родного", "города", "буквоград", "заголовок", "деревни", "алфавит", "подзаголовок", "своего", "переулка", "грустный", "реторический", "вопрос", "скатился", "его", "щеке", "продолжил", "свой", "путь", "дороге", "встретил", "рукопись", "она", "предупредила", "моей", "все", "переписывается", "несколько", "раз", "единственное", "что", "меня", "осталось", "это", "приставка", "возвращайся", "ты", "лучше", "свою", "безопасную", "страну", "послушавшись", "рукописи", "наш", "продолжил", "свой", "путь", "вскоре", "ему", "повстречался", "коварный", "составитель", "рекламных", "текстов", "напоивший", "языком", "речью", "заманивший", "свое", "агенство", "которое", "использовало", "снова", "снова", "своих", "проектах", "если", "переписали", "то", "живет", "там", "до", "сих", "пор"] } }; var r = e("preferences"); r.define("lorem.defaultLang", "en"); e("abbreviationParser").addPreprocessor(function (e, t) { var n = /^(?:lorem|lipsum)([a-z]{2})?(\d*)$/i, i; e.findAll(function (e) { if (e._name && (i = e._name.match(n))) { var t = i[2] || 30; var s = i[1] || r.get("lorem.defaultLang") || "en"; e._name = ""; e.data("forceNameResolving", e.isRepeating() || e.attributeList().length); e.data("pasteOverwrites", true); e.data("paste", function (e, n) { return f(s, t, !e) }) } }) }); return { addLang: function (e, r) { if (t.isString(r)) { r = { words: t.compact(r.split(" ")) } } else if (t.isArray(r)) { r = { words: r } } n[e] = r } } }); emmet.define("bootstrap", function (e, t) { var n = { variables: { lang: "en", locale: "en-US", charset: "UTF-8", indentation: "	", newline: "\n" }, css: { filters: "html", snippets: { "@i": "@import url(|);", "@import": "@import url(|);", "@m": "@media ${1:screen} {\n	|\n}", "@media": "@media ${1:screen} {\n	|\n}", "@f": "@font-face {\n	font-family:|;\n	src:url(|);\n}", "@f+": "@font-face {\n	font-family: '${1:FontName}';\n	src: url('${2:FileName}.eot');\n	src: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n		 url('${2:FileName}.woff') format('woff'),\n		 url('${2:FileName}.ttf') format('truetype'),\n		 url('${2:FileName}.svg#${1:FontName}') format('svg');\n	font-style: ${3:normal};\n	font-weight: ${4:normal};\n}", "@kf": "@-webkit-keyframes ${1:identifier} {\n	${2:from} { ${3} }${6}\n	${4:to} { ${5} }\n}\n@-o-keyframes ${1:identifier} {\n	${2:from} { ${3} }${6}\n	${4:to} { ${5} }\n}\n@-moz-keyframes ${1:identifier} {\n	${2:from} { ${3} }${6}\n	${4:to} { ${5} }\n}\n@keyframes ${1:identifier} {\n	${2:from} { ${3} }${6}\n	${4:to} { ${5} }\n}", anim: "animation:|;", "anim-": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};", animdel: "animation-delay:${1:time};", animdir: "animation-direction:${1:normal};", "animdir:n": "animation-direction:normal;", "animdir:r": "animation-direction:reverse;", "animdir:a": "animation-direction:alternate;", "animdir:ar": "animation-direction:alternate-reverse;", animdur: "animation-duration:${1:0}s;", animfm: "animation-fill-mode:${1:both};", "animfm:f": "animation-fill-mode:forwards;", "animfm:b": "animation-fill-mode:backwards;", "animfm:bt": "animation-fill-mode:both;", "animfm:bh": "animation-fill-mode:both;", animic: "animation-iteration-count:${1:1};", "animic:i": "animation-iteration-count:infinite;", animn: "animation-name:${1:none};", animps: "animation-play-state:${1:running};", "animps:p": "animation-play-state:paused;", "animps:r": "animation-play-state:running;", animtf: "animation-timing-function:${1:linear};", "animtf:e": "animation-timing-function:ease;", "animtf:ei": "animation-timing-function:ease-in;", "animtf:eo": "animation-timing-function:ease-out;", "animtf:eio": "animation-timing-function:ease-in-out;", "animtf:l": "animation-timing-function:linear;", "animtf:cb": "animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});", ap: "appearance:${none};", "!": "!important", pos: "position:${1:relative};", "pos:s": "position:static;", "pos:a": "position:absolute;", "pos:r": "position:relative;", "pos:f": "position:fixed;", t: "top:|;", "t:a": "top:auto;", r: "right:|;", "r:a": "right:auto;", b: "bottom:|;", "b:a": "bottom:auto;", l: "left:|;", "l:a": "left:auto;", z: "z-index:|;", "z:a": "z-index:auto;", fl: "float:${1:left};", "fl:n": "float:none;", "fl:l": "float:left;", "fl:r": "float:right;", cl: "clear:${1:both};", "cl:n": "clear:none;", "cl:l": "clear:left;", "cl:r": "clear:right;", "cl:b": "clear:both;", colm: "columns:|;", colmc: "column-count:|;", colmf: "column-fill:|;", colmg: "column-gap:|;", colmr: "column-rule:|;", colmrc: "column-rule-color:|;", colmrs: "column-rule-style:|;", colmrw: "column-rule-width:|;", colms: "column-span:|;", colmw: "column-width:|;", d: "display:${1:block};", "d:n": "display:none;", "d:b": "display:block;", "d:i": "display:inline;", "d:ib": "display:inline-block;", "d:ib+": "display: inline-block;\n*display: inline;\n*zoom: 1;", "d:li": "display:list-item;", "d:ri": "display:run-in;", "d:cp": "display:compact;", "d:tb": "display:table;", "d:itb": "display:inline-table;", "d:tbcp": "display:table-caption;", "d:tbcl": "display:table-column;", "d:tbclg": "display:table-column-group;", "d:tbhg": "display:table-header-group;", "d:tbfg": "display:table-footer-group;", "d:tbr": "display:table-row;", "d:tbrg": "display:table-row-group;", "d:tbc": "display:table-cell;", "d:rb": "display:ruby;", "d:rbb": "display:ruby-base;", "d:rbbg": "display:ruby-base-group;", "d:rbt": "display:ruby-text;", "d:rbtg": "display:ruby-text-group;", v: "visibility:${1:hidden};", "v:v": "visibility:visible;", "v:h": "visibility:hidden;", "v:c": "visibility:collapse;", ov: "overflow:${1:hidden};", "ov:v": "overflow:visible;", "ov:h": "overflow:hidden;", "ov:s": "overflow:scroll;", "ov:a": "overflow:auto;", ovx: "overflow-x:${1:hidden};", "ovx:v": "overflow-x:visible;", "ovx:h": "overflow-x:hidden;", "ovx:s": "overflow-x:scroll;", "ovx:a": "overflow-x:auto;", ovy: "overflow-y:${1:hidden};", "ovy:v": "overflow-y:visible;", "ovy:h": "overflow-y:hidden;", "ovy:s": "overflow-y:scroll;", "ovy:a": "overflow-y:auto;", ovs: "overflow-style:${1:scrollbar};", "ovs:a": "overflow-style:auto;", "ovs:s": "overflow-style:scrollbar;", "ovs:p": "overflow-style:panner;", "ovs:m": "overflow-style:move;", "ovs:mq": "overflow-style:marquee;", zoo: "zoom:1;", zm: "zoom:1;", cp: "clip:|;", "cp:a": "clip:auto;", "cp:r": "clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});", bxz: "box-sizing:${1:border-box};", "bxz:cb": "box-sizing:content-box;", "bxz:bb": "box-sizing:border-box;", bxsh: "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};", "bxsh:r": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});", "bxsh:ra": "box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});", "bxsh:n": "box-shadow:none;", m: "margin:|;", "m:a": "margin:auto;", mt: "margin-top:|;", "mt:a": "margin-top:auto;", mr: "margin-right:|;", "mr:a": "margin-right:auto;", mb: "margin-bottom:|;", "mb:a": "margin-bottom:auto;", ml: "margin-left:|;", "ml:a": "margin-left:auto;", p: "padding:|;", pt: "padding-top:|;", pr: "padding-right:|;", pb: "padding-bottom:|;", pl: "padding-left:|;", w: "width:|;", "w:a": "width:auto;", h: "height:|;", "h:a": "height:auto;", maw: "max-width:|;", "maw:n": "max-width:none;", mah: "max-height:|;", "mah:n": "max-height:none;", miw: "min-width:|;", mih: "min-height:|;", mar: "max-resolution:${1:res};", mir: "min-resolution:${1:res};", ori: "orientation:|;", "ori:l": "orientation:landscape;", "ori:p": "orientation:portrait;", ol: "outline:|;", "ol:n": "outline:none;", olo: "outline-offset:|;", olw: "outline-width:|;", "olw:tn": "outline-width:thin;", "olw:m": "outline-width:medium;", "olw:tc": "outline-width:thick;", ols: "outline-style:|;", "ols:n": "outline-style:none;", "ols:dt": "outline-style:dotted;", "ols:ds": "outline-style:dashed;", "ols:s": "outline-style:solid;", "ols:db": "outline-style:double;", "ols:g": "outline-style:groove;", "ols:r": "outline-style:ridge;", "ols:i": "outline-style:inset;", "ols:o": "outline-style:outset;", olc: "outline-color:#${1:000};", "olc:i": "outline-color:invert;", bd: "border:|;", "bd+": "border:${1:1px} ${2:solid} ${3:#000};", "bd:n": "border:none;", bdbk: "border-break:${1:close};", "bdbk:c": "border-break:close;", bdcl: "border-collapse:|;", "bdcl:c": "border-collapse:collapse;", "bdcl:s": "border-collapse:separate;", bdc: "border-color:#${1:000};", "bdc:t": "border-color:transparent;", bdi: "border-image:url(|);", "bdi:n": "border-image:none;", bdti: "border-top-image:url(|);", "bdti:n": "border-top-image:none;", bdri: "border-right-image:url(|);", "bdri:n": "border-right-image:none;", bdbi: "border-bottom-image:url(|);", "bdbi:n": "border-bottom-image:none;", bdli: "border-left-image:url(|);", "bdli:n": "border-left-image:none;", bdci: "border-corner-image:url(|);", "bdci:n": "border-corner-image:none;", "bdci:c": "border-corner-image:continue;", bdtli: "border-top-left-image:url(|);", "bdtli:n": "border-top-left-image:none;", "bdtli:c": "border-top-left-image:continue;", bdtri: "border-top-right-image:url(|);", "bdtri:n": "border-top-right-image:none;", "bdtri:c": "border-top-right-image:continue;", bdbri: "border-bottom-right-image:url(|);", "bdbri:n": "border-bottom-right-image:none;", "bdbri:c": "border-bottom-right-image:continue;", bdbli: "border-bottom-left-image:url(|);", "bdbli:n": "border-bottom-left-image:none;", "bdbli:c": "border-bottom-left-image:continue;", bdf: "border-fit:${1:repeat};", "bdf:c": "border-fit:clip;", "bdf:r": "border-fit:repeat;", "bdf:sc": "border-fit:scale;", "bdf:st": "border-fit:stretch;", "bdf:ow": "border-fit:overwrite;", "bdf:of": "border-fit:overflow;", "bdf:sp": "border-fit:space;", bdlen: "border-length:|;", "bdlen:a": "border-length:auto;", bdsp: "border-spacing:|;", bds: "border-style:|;", "bds:n": "border-style:none;", "bds:h": "border-style:hidden;", "bds:dt": "border-style:dotted;", "bds:ds": "border-style:dashed;", "bds:s": "border-style:solid;", "bds:db": "border-style:double;", "bds:dtds": "border-style:dot-dash;", "bds:dtdtds": "border-style:dot-dot-dash;", "bds:w": "border-style:wave;", "bds:g": "border-style:groove;", "bds:r": "border-style:ridge;", "bds:i": "border-style:inset;", "bds:o": "border-style:outset;", bdw: "border-width:|;", bdtw: "border-top-width:|;", bdrw: "border-right-width:|;", bdbw: "border-bottom-width:|;", bdlw: "border-left-width:|;", bdt: "border-top:|;", bt: "border-top:|;", "bdt+": "border-top:${1:1px} ${2:solid} ${3:#000};", "bdt:n": "border-top:none;", bdts: "border-top-style:|;", "bdts:n": "border-top-style:none;", bdtc: "border-top-color:#${1:000};", "bdtc:t": "border-top-color:transparent;", bdr: "border-right:|;", br: "border-right:|;", "bdr+": "border-right:${1:1px} ${2:solid} ${3:#000};", "bdr:n": "border-right:none;", bdrst: "border-right-style:|;", "bdrst:n": "border-right-style:none;", bdrc: "border-right-color:#${1:000};", "bdrc:t": "border-right-color:transparent;", bdb: "border-bottom:|;", bb: "border-bottom:|;", "bdb+": "border-bottom:${1:1px} ${2:solid} ${3:#000};", "bdb:n": "border-bottom:none;", bdbs: "border-bottom-style:|;", "bdbs:n": "border-bottom-style:none;", bdbc: "border-bottom-color:#${1:000};", "bdbc:t": "border-bottom-color:transparent;", bdl: "border-left:|;", bl: "border-left:|;", "bdl+": "border-left:${1:1px} ${2:solid} ${3:#000};", "bdl:n": "border-left:none;", bdls: "border-left-style:|;", "bdls:n": "border-left-style:none;", bdlc: "border-left-color:#${1:000};", "bdlc:t": "border-left-color:transparent;", bdrs: "border-radius:|;", bdtrrs: "border-top-right-radius:|;", bdtlrs: "border-top-left-radius:|;", bdbrrs: "border-bottom-right-radius:|;", bdblrs: "border-bottom-left-radius:|;", bg: "background:#${1:000};", "bg+": "background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};", "bg:n": "background:none;", "bg:ie": "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');", bgc: "background-color:#${1:fff};", "bgc:t": "background-color:transparent;", bgi: "background-image:url(|);", "bgi:n": "background-image:none;", bgr: "background-repeat:|;", "bgr:n": "background-repeat:no-repeat;", "bgr:x": "background-repeat:repeat-x;", "bgr:y": "background-repeat:repeat-y;", "bgr:sp": "background-repeat:space;", "bgr:rd": "background-repeat:round;", bga: "background-attachment:|;", "bga:f": "background-attachment:fixed;", "bga:s": "background-attachment:scroll;", bgp: "background-position:${1:0} ${2:0};", bgpx: "background-position-x:|;", bgpy: "background-position-y:|;", bgbk: "background-break:|;", "bgbk:bb": "background-break:bounding-box;", "bgbk:eb": "background-break:each-box;", "bgbk:c": "background-break:continuous;", bgcp: "background-clip:${1:padding-box};", "bgcp:bb": "background-clip:border-box;", "bgcp:pb": "background-clip:padding-box;", "bgcp:cb": "background-clip:content-box;", "bgcp:nc": "background-clip:no-clip;", bgo: "background-origin:|;", "bgo:pb": "background-origin:padding-box;", "bgo:bb": "background-origin:border-box;", "bgo:cb": "background-origin:content-box;", bgsz: "background-size:|;", "bgsz:a": "background-size:auto;", "bgsz:ct": "background-size:contain;", "bgsz:cv": "background-size:cover;", c: "color:#${1:000};", "c:r": "color:rgb(${1:0}, ${2:0}, ${3:0});", "c:ra": "color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});", cm: "/* |${child} */", cnt: "content:'|';", "cnt:n": "content:normal;", "cnt:oq": "content:open-quote;", "cnt:noq": "content:no-open-quote;", "cnt:cq": "content:close-quote;", "cnt:ncq": "content:no-close-quote;", "cnt:a": "content:attr(|);", "cnt:c": "content:counter(|);", "cnt:cs": "content:counters(|);", tbl: "table-layout:|;", "tbl:a": "table-layout:auto;", "tbl:f": "table-layout:fixed;", cps: "caption-side:|;", "cps:t": "caption-side:top;", "cps:b": "caption-side:bottom;", ec: "empty-cells:|;", "ec:s": "empty-cells:show;", "ec:h": "empty-cells:hide;", lis: "list-style:|;", "lis:n": "list-style:none;", lisp: "list-style-position:|;", "lisp:i": "list-style-position:inside;", "lisp:o": "list-style-position:outside;", list: "list-style-type:|;", "list:n": "list-style-type:none;", "list:d": "list-style-type:disc;", "list:c": "list-style-type:circle;", "list:s": "list-style-type:square;", "list:dc": "list-style-type:decimal;", "list:dclz": "list-style-type:decimal-leading-zero;", "list:lr": "list-style-type:lower-roman;", "list:ur": "list-style-type:upper-roman;", lisi: "list-style-image:|;", "lisi:n": "list-style-image:none;", q: "quotes:|;", "q:n": "quotes:none;", "q:ru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C';", "q:en": "quotes:'\\201C' '\\201D' '\\2018' '\\2019';", ct: "content:|;", "ct:n": "content:normal;", "ct:oq": "content:open-quote;", "ct:noq": "content:no-open-quote;", "ct:cq": "content:close-quote;", "ct:ncq": "content:no-close-quote;", "ct:a": "content:attr(|);", "ct:c": "content:counter(|);", "ct:cs": "content:counters(|);", coi: "counter-increment:|;", cor: "counter-reset:|;", va: "vertical-align:${1:top};", "va:sup": "vertical-align:super;", "va:t": "vertical-align:top;", "va:tt": "vertical-align:text-top;", "va:m": "vertical-align:middle;", "va:bl": "vertical-align:baseline;", "va:b": "vertical-align:bottom;", "va:tb": "vertical-align:text-bottom;", "va:sub": "vertical-align:sub;", ta: "text-align:${1:left};", "ta:l": "text-align:left;", "ta:c": "text-align:center;", "ta:r": "text-align:right;", "ta:j": "text-align:justify;", "ta-lst": "text-align-last:|;", "tal:a": "text-align-last:auto;", "tal:l": "text-align-last:left;", "tal:c": "text-align-last:center;", "tal:r": "text-align-last:right;", td: "text-decoration:${1:none};", "td:n": "text-decoration:none;", "td:u": "text-decoration:underline;", "td:o": "text-decoration:overline;", "td:l": "text-decoration:line-through;", te: "text-emphasis:|;", "te:n": "text-emphasis:none;", "te:ac": "text-emphasis:accent;", "te:dt": "text-emphasis:dot;", "te:c": "text-emphasis:circle;", "te:ds": "text-emphasis:disc;", "te:b": "text-emphasis:before;", "te:a": "text-emphasis:after;", th: "text-height:|;", "th:a": "text-height:auto;", "th:f": "text-height:font-size;", "th:t": "text-height:text-size;", "th:m": "text-height:max-size;", ti: "text-indent:|;", "ti:-": "text-indent:-9999px;", tj: "text-justify:|;", "tj:a": "text-justify:auto;", "tj:iw": "text-justify:inter-word;", "tj:ii": "text-justify:inter-ideograph;", "tj:ic": "text-justify:inter-cluster;", "tj:d": "text-justify:distribute;", "tj:k": "text-justify:kashida;", "tj:t": "text-justify:tibetan;", tov: "text-overflow:${ellipsis};", "tov:e": "text-overflow:ellipsis;", "tov:c": "text-overflow:clip;", to: "text-outline:|;", "to+": "text-outline:${1:0} ${2:0} ${3:#000};", "to:n": "text-outline:none;", tr: "text-replace:|;", "tr:n": "text-replace:none;", tt: "text-transform:${1:uppercase};", "tt:n": "text-transform:none;", "tt:c": "text-transform:capitalize;", "tt:u": "text-transform:uppercase;", "tt:l": "text-transform:lowercase;", tw: "text-wrap:|;", "tw:n": "text-wrap:normal;", "tw:no": "text-wrap:none;", "tw:u": "text-wrap:unrestricted;", "tw:s": "text-wrap:suppress;", tsh: "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};", "tsh:r": "text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});", "tsh:ra": "text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});", "tsh+": "text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};", "tsh:n": "text-shadow:none;", trf: "transform:|;", "trf:skx": "transform: skewX(${1:angle});", "trf:sky": "transform: skewY(${1:angle});", "trf:sc": "transform: scale(${1:x}, ${2:y});", "trf:scx": "transform: scaleX(${1:x});", "trf:scy": "transform: scaleY(${1:y});", "trf:r": "transform: rotate(${1:angle});", "trf:t": "transform: translate(${1:x}, ${2:y});", "trf:tx": "transform: translateX(${1:x});", "trf:ty": "transform: translateY(${1:y});", trfo: "transform-origin:|;", trfs: "transform-style:${1:preserve-3d};", trs: "transition:${1:prop} ${2:time};", trsde: "transition-delay:${1:time};", trsdu: "transition-duration:${1:time};", trsp: "transition-property:${1:prop};", trstf: "transition-timing-function:${1:tfunc};", lh: "line-height:|;", whs: "white-space:|;", "whs:n": "white-space:normal;", "whs:p": "white-space:pre;", "whs:nw": "white-space:nowrap;", "whs:pw": "white-space:pre-wrap;", "whs:pl": "white-space:pre-line;", whsc: "white-space-collapse:|;", "whsc:n": "white-space-collapse:normal;", "whsc:k": "white-space-collapse:keep-all;", "whsc:l": "white-space-collapse:loose;", "whsc:bs": "white-space-collapse:break-strict;", "whsc:ba": "white-space-collapse:break-all;", wob: "word-break:|;", "wob:n": "word-break:normal;", "wob:k": "word-break:keep-all;", "wob:ba": "word-break:break-all;", wos: "word-spacing:|;", wow: "word-wrap:|;", "wow:nm": "word-wrap:normal;", "wow:n": "word-wrap:none;", "wow:u": "word-wrap:unrestricted;", "wow:s": "word-wrap:suppress;", "wow:b": "word-wrap:break-word;", wm: "writing-mode:${1:lr-tb};", "wm:lrt": "writing-mode:lr-tb;", "wm:lrb": "writing-mode:lr-bt;", "wm:rlt": "writing-mode:rl-tb;", "wm:rlb": "writing-mode:rl-bt;", "wm:tbr": "writing-mode:tb-rl;", "wm:tbl": "writing-mode:tb-lr;", "wm:btl": "writing-mode:bt-lr;", "wm:btr": "writing-mode:bt-rl;", lts: "letter-spacing:|;", "lts-n": "letter-spacing:normal;", f: "font:|;", "f+": "font:${1:1em} ${2:Arial,sans-serif};", fw: "font-weight:|;", "fw:n": "font-weight:normal;", "fw:b": "font-weight:bold;", "fw:br": "font-weight:bolder;", "fw:lr": "font-weight:lighter;", fs: "font-style:${italic};", "fs:n": "font-style:normal;", "fs:i": "font-style:italic;", "fs:o": "font-style:oblique;", fv: "font-variant:|;", "fv:n": "font-variant:normal;", "fv:sc": "font-variant:small-caps;", fz: "font-size:|;", fza: "font-size-adjust:|;", "fza:n": "font-size-adjust:none;", ff: "font-family:|;", "ff:s": "font-family:serif;", "ff:ss": "font-family:sans-serif;", "ff:c": "font-family:cursive;", "ff:f": "font-family:fantasy;", "ff:m": "font-family:monospace;", "ff:a": 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;', "ff:t": 'font-family: "Times New Roman", Times, Baskerville, Georgia, serif;', "ff:v": "font-family: Verdana, Geneva, sans-serif;", fef: "font-effect:|;", "fef:n": "font-effect:none;", "fef:eg": "font-effect:engrave;", "fef:eb": "font-effect:emboss;", "fef:o": "font-effect:outline;", fem: "font-emphasize:|;", femp: "font-emphasize-position:|;", "femp:b": "font-emphasize-position:before;", "femp:a": "font-emphasize-position:after;", fems: "font-emphasize-style:|;", "fems:n": "font-emphasize-style:none;", "fems:ac": "font-emphasize-style:accent;", "fems:dt": "font-emphasize-style:dot;", "fems:c": "font-emphasize-style:circle;", "fems:ds": "font-emphasize-style:disc;", fsm: "font-smooth:|;", "fsm:a": "font-smooth:auto;", "fsm:n": "font-smooth:never;", "fsm:aw": "font-smooth:always;", fst: "font-stretch:|;", "fst:n": "font-stretch:normal;", "fst:uc": "font-stretch:ultra-condensed;", "fst:ec": "font-stretch:extra-condensed;", "fst:c": "font-stretch:condensed;", "fst:sc": "font-stretch:semi-condensed;", "fst:se": "font-stretch:semi-expanded;", "fst:e": "font-stretch:expanded;", "fst:ee": "font-stretch:extra-expanded;", "fst:ue": "font-stretch:ultra-expanded;", op: "opacity:|;", "op+": "opacity: $1;\nfilter: alpha(opacity=$2);", "op:ie": "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);", "op:ms": "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';", rsz: "resize:|;", "rsz:n": "resize:none;", "rsz:b": "resize:both;", "rsz:h": "resize:horizontal;", "rsz:v": "resize:vertical;", cur: "cursor:${pointer};", "cur:a": "cursor:auto;", "cur:d": "cursor:default;", "cur:c": "cursor:crosshair;", "cur:ha": "cursor:hand;", "cur:he": "cursor:help;", "cur:m": "cursor:move;", "cur:p": "cursor:pointer;", "cur:t": "cursor:text;", pgbb: "page-break-before:|;", "pgbb:au": "page-break-before:auto;", "pgbb:al": "page-break-before:always;", "pgbb:l": "page-break-before:left;", "pgbb:r": "page-break-before:right;", pgbi: "page-break-inside:|;", "pgbi:au": "page-break-inside:auto;", "pgbi:av": "page-break-inside:avoid;", pgba: "page-break-after:|;", "pgba:au": "page-break-after:auto;", "pgba:al": "page-break-after:always;", "pgba:l": "page-break-after:left;", "pgba:r": "page-break-after:right;", orp: "orphans:|;", us: "user-select:${none};", wid: "widows:|;", wfsm: "-webkit-font-smoothing:${antialiased};", "wfsm:a": "-webkit-font-smoothing:antialiased;", "wfsm:s": "-webkit-font-smoothing:subpixel-antialiased;", "wfsm:sa": "-webkit-font-smoothing:subpixel-antialiased;", "wfsm:n": "-webkit-font-smoothing:none;" } }, html: { filters: "html", profile: "html", snippets: { "!!!": "<!doctype html>", "!!!4t": '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">', "!!!4s": '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">', "!!!xt": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">', "!!!xs": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">', "!!!xxs": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">', c: "<!-- |${child} -->", "cc:ie6": "<!--[if lte IE 6]>\n	${child}|\n<![endif]-->", "cc:ie": "<!--[if IE]>\n	${child}|\n<![endif]-->", "cc:noie": "<!--[if !IE]><!-->\n	${child}|\n<!--<![endif]-->" }, abbreviations: { "!": "html:5", a: '<a href="">', "a:link": '<a href="http://|">', "a:mail": '<a href="mailto:|">', abbr: '<abbr title="">', acronym: '<acronym title="">', base: '<base href="" />', basefont: "<basefont/>", br: "<br/>", frame: "<frame/>", hr: "<hr/>", bdo: '<bdo dir="">', "bdo:r": '<bdo dir="rtl">', "bdo:l": '<bdo dir="ltr">', col: "<col/>", link: '<link rel="stylesheet" href="" />', "link:css": '<link rel="stylesheet" href="${1:style}.css" />', "link:print": '<link rel="stylesheet" href="${1:print}.css" media="print" />', "link:favicon": '<link rel="shortcut icon" type="image/x-icon" href="${1:favicon.ico}" />', "link:touch": '<link rel="apple-touch-icon" href="${1:favicon.png}" />', "link:rss": '<link rel="alternate" type="application/rss+xml" title="RSS" href="${1:rss.xml}" />', "link:atom": '<link rel="alternate" type="application/atom+xml" title="Atom" href="${1:atom.xml}" />', meta: "<meta/>", "meta:utf": '<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />', "meta:win": '<meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />', "meta:vp": '<meta name="viewport" content="width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}" />', "meta:compat": '<meta http-equiv="X-UA-Compatible" content="${1:IE=7}" />', style: "<style>", script: "<script>", "script:src": '<script src="">', img: '<img src="" alt="" />', iframe: '<iframe src="" frameborder="0">', embed: '<embed src="" type="" />', object: '<object data="" type="">', param: '<param name="" value="" />', map: '<map name="">', area: '<area shape="" coords="" href="" alt="" />', "area:d": '<area shape="default" href="" alt="" />', "area:c": '<area shape="circle" coords="" href="" alt="" />', "area:r": '<area shape="rect" coords="" href="" alt="" />', "area:p": '<area shape="poly" coords="" href="" alt="" />', form: '<form action="">', "form:get": '<form action="" method="get">', "form:post": '<form action="" method="post">', label: '<label for="">', input: '<input type="${1:text}" />', inp: '<input type="${1:text}" name="" id="" />', "input:hidden": "input[type=hidden name]", "input:h": "input:hidden", "input:text": "inp", "input:t": "inp", "input:search": "inp[type=search]", "input:email": "inp[type=email]", "input:url": "inp[type=url]", "input:password": "inp[type=password]", "input:p": "input:password", "input:datetime": "inp[type=datetime]", "input:date": "inp[type=date]", "input:datetime-local": "inp[type=datetime-local]", "input:month": "inp[type=month]", "input:week": "inp[type=week]", "input:time": "inp[type=time]", "input:number": "inp[type=number]", "input:color": "inp[type=color]", "input:checkbox": "inp[type=checkbox]", "input:c": "input:checkbox", "input:radio": "inp[type=radio]", "input:r": "input:radio", "input:range": "inp[type=range]", "input:file": "inp[type=file]", "input:f": "input:file", "input:submit": '<input type="submit" value="" />', "input:s": "input:submit", "input:image": '<input type="image" src="" alt="" />', "input:i": "input:image", "input:button": '<input type="button" value="" />', "input:b": "input:button", isindex: "<isindex/>", "input:reset": "input:button[type=reset]", select: '<select name="" id="">', "select:disabled": "select[disabled]", "select:d": "select[disabled]", option: '<option value="">', textarea: '<textarea name="" id="" cols="${1:30}" rows="${2:10}">', marquee: '<marquee behavior="" direction="">', "menu:context": "menu[type=context]>", "menu:c": "menu:context", "menu:toolbar": "menu[type=toolbar]>", "menu:t": "menu:toolbar", video: '<video src="">', audio: '<audio src="">', "html:xml": '<html xmlns="http://www.w3.org/1999/xhtml">', keygen: "<keygen/>", command: "<command/>", "button:submit": "button[type=submit]", "button:s": "button[type=submit]", "button:reset": "button[type=reset]", "button:r": "button[type=reset]", "button:disabled": "button[disabled]", "button:d": "button[disabled]", "fieldset:disabled": "fieldset[disabled]", "fieldset:d": "fieldset[disabled]", bq: "blockquote", acr: "acronym", fig: "figure", figc: "figcaption", ifr: "iframe", emb: "embed", obj: "object", src: "source", cap: "caption", colg: "colgroup", fst: "fieldset", "fst:d": "fieldset[disabled]", btn: "button", "btn:b": "button[type=button]", "btn:r": "button[type=reset]", "btn:s": "button[type=submit]", "btn:d": "button[disabled]", optg: "optgroup", opt: "option", tarea: "textarea", leg: "legend", sect: "section", art: "article", hdr: "header", ftr: "footer", adr: "address", dlg: "dialog", str: "strong", prog: "progress", fset: "fieldset", "fset:d": "fieldset[disabled]", datag: "datagrid", datal: "datalist", kg: "keygen", out: "output", det: "details", cmd: "command", doc: "html>(head>meta[charset=UTF-8]+title{${1:Document}})+body", doc4: 'html>(head>meta[http-equiv="Content-Type" content="text/html;charset=${charset}"]+title{${1:Document}})+body', "html:4t": "!!!4t+doc4[lang=${lang}]", "html:4s": "!!!4s+doc4[lang=${lang}]", "html:xt": "!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]", "html:xs": "!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]", "html:xxs": "!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]", "html:5": "!!!+doc[lang=${lang}]", "ol+": "ol>li", "ul+": "ul>li", "dl+": "dl>dt+dd", "map+": "map>area", "table+": "table>tr>td", "colgroup+": "colgroup>col", "colg+": "colgroup>col", "tr+": "tr>td", "select+": "select>option", "optgroup+": "optgroup>option", "optg+": "optgroup>option" } }, xml: { "extends": "html", profile: "xml", filters: "html" }, xsl: { "extends": "html", profile: "xml", filters: "html, xsl", abbreviations: { tm: '<xsl:template match="" mode="">', tmatch: "tm", tn: '<xsl:template name="">', tname: "tn", call: '<xsl:call-template name=""/>', ap: '<xsl:apply-templates select="" mode=""/>', api: "<xsl:apply-imports/>", imp: '<xsl:import href=""/>', inc: '<xsl:include href=""/>', ch: "<xsl:choose>", "xsl:when": '<xsl:when test="">', wh: "xsl:when", ot: "<xsl:otherwise>", "if": '<xsl:if test="">', par: '<xsl:param name="">', pare: '<xsl:param name="" select=""/>', "var": '<xsl:variable name="">', vare: '<xsl:variable name="" select=""/>', wp: '<xsl:with-param name="" select=""/>', key: '<xsl:key name="" match="" use=""/>', elem: '<xsl:element name="">', attr: '<xsl:attribute name="">', attrs: '<xsl:attribute-set name="">', cp: '<xsl:copy select=""/>', co: '<xsl:copy-of select=""/>', val: '<xsl:value-of select=""/>', each: '<xsl:for-each select="">', "for": "each", tex: "<xsl:text></xsl:text>", com: "<xsl:comment>", msg: '<xsl:message terminate="no">', fall: "<xsl:fallback>", num: '<xsl:number value=""/>', nam: '<namespace-alias stylesheet-prefix="" result-prefix=""/>', pres: '<xsl:preserve-space elements=""/>', strip: '<xsl:strip-space elements=""/>', proc: '<xsl:processing-instruction name="">', sort: '<xsl:sort select="" order=""/>', "choose+": "xsl:choose>xsl:when+xsl:otherwise", xsl: "!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\n|}" }, snippets: { "!!!": '<?xml version="1.0" encoding="UTF-8"?>' } }, haml: { filters: "haml", "extends": "html", profile: "xml" }, scss: { "extends": "css" }, sass: { "extends": "css" }, less: { "extends": "css" }, stylus: { "extends": "css" }, styl: { "extends": "stylus" } }; var r = e("resources"); var i = r.getVocabulary("user") || {}; r.setVocabulary(e("utils").deepMerge(i, n), "user") })